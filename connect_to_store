#!/usr/bin/env python3

import socket
import sys
import os
import selectors
import struct

import nar
import construct
from construct import Struct, Const, Int64ul, Pass

def eprint(*args, **kwargs):
    kwargs['file'] = sys.stderr
    print(*args, **kwargs)

WORKER_MAGIC_1 = 0x6e697863
WORKER_MAGIC_2 = 0x6478696f
wop_to_num = {
    "wopIsValidPath": 1,
    "wopHasSubstitutes": 3,
    "wopQueryPathHash": 4,
    "wopQueryReferences": 5,
    "wopQueryReferrers": 6,
    "wopAddToStore": 7,
    "wopAddTextToStore": 8,
    "wopBuildPaths": 9,
    "wopEnsurePath": 10,
    "wopAddTempRoot": 11,
    "wopAddIndirectRoot": 12,
    "wopSyncWithGC": 13,
    "wopFindRoots": 14,
    "wopExportPath": 16,
    "wopQueryDeriver": 18,
    "wopSetOptions": 19,
    "wopCollectGarbage": 20,
    "wopQuerySubstitutablePathInfo": 21,
    "wopQueryDerivationOutputs": 22,
    "wopQueryAllValidPaths": 23,
    "wopQueryFailedPaths": 24,
    "wopClearFailedPaths": 25,
    "wopQueryPathInfo": 26,
    "wopImportPaths": 27,
    "wopQueryDerivationOutputNames": 28,
    "wopQueryPathFromHashPart": 29,
    "wopQuerySubstitutablePathInfos": 30,
    "wopQueryValidPaths": 31,
    "wopQuerySubstitutablePaths": 32,
    "wopQueryValidDerivers": 33,
    "wopOptimiseStore": 34,
    "wopVerifyStore": 35,
    "wopBuildDerivation": 36,
    "wopAddSignatures": 37,
    "wopNarFromPath": 38,
    "wopAddToStoreNar": 39,
    "wopQueryMissing": 40,
}
nixstr = construct.Aligned(8, construct.PascalString(construct.Int64ul, encoding="utf8"))
op_enum = construct.Enum(Int64ul, **wop_to_num)
wopSetOptions = Struct(
    "keepFailed" / Int64ul,
    "keepGoing" / Int64ul,
    "tryFallback" / Int64ul,
    "verbosity" / Int64ul,
    "maxBuildJobs" / Int64ul,
    "maxSilentTime" / Int64ul,
    "useBuildHook" / Int64ul,
    "verboseBuild" / Int64ul,
    "logType" / Int64ul,
    "printBuildTrace" / Int64ul,
    "buildCores" / Int64ul,
    "useSubstitutes" / Int64ul,
    "overrides" / construct.PrefixedArray(Int64ul, Struct(
        "option" / nixstr,
        "value" / nixstr
    ))
)
wopAddToStore = Struct(
    "baseName" / nixstr,
    "fixed" / Int64ul,
    "recursive" / Int64ul,
    "hashType" / nixstr,
    "nar" / nar.dump
)
wopAddTextToStore = Struct(
    "baseName" / nixstr,
    "string" / nixstr,
    "references" / construct.PrefixedArray(Int64ul, nixstr)
)
wopBuildPaths = Struct(
    "paths" / construct.PrefixedArray(Int64ul, nixstr),
    "mode" / Int64ul
)
wopQuerySubstitutablePathInfos = Struct(
    "paths" / construct.PrefixedArray(Int64ul, nixstr),
)
gc_action_to_num = {
    "gcReturnLive": 0,
    "gcReturnDead": 1,
    "gcDeleteDead": 2,
    "gcDeleteSpecific": 3,
}
gc_action_enum = construct.Enum(Int64ul, **gc_action_to_num)
wopCollectGarbage = Struct(
    "action" / gc_action_enum,
    "pathsToDelete" / construct.PrefixedArray(Int64ul, nixstr),
    "ignoreLiveness" / Int64ul,
    "maxFreed" / Int64ul,
    # obsolete fields
    construct.Const(Int64ul, 0),
    construct.Const(Int64ul, 0),
    construct.Const(Int64ul, 0)
)
op_request = {
    "wopSetOptions":wopSetOptions,
    "wopAddToStore":wopAddToStore,
    "wopAddTextToStore":wopAddTextToStore,
    "wopIsValidPath": Struct("path"/nixstr),
    "wopEnsurePath": Struct("path"/nixstr),
    "wopBuildPaths":wopBuildPaths,
    "wopQueryPathInfo": Struct("path"/nixstr),
    "wopQueryReferrers": Struct("path"/nixstr),
    "wopQueryDerivationOutputs": Struct("path"/nixstr),
    "wopQuerySubstitutablePathInfos":wopQuerySubstitutablePathInfos,
    "wopAddTempRoot": Struct("path"/nixstr),
    "wopAddIndirectRoot": Struct("path"/nixstr),
    "wopFindRoots": Struct(),
    "wopSyncWithGC": Struct(),
    "wopCollectGarbage":wopCollectGarbage,
}

map_entry = Struct(
    "key" / nixstr,
    "value" / nixstr
)
empty_response = Struct(
)
int_response = Struct(
    "ret" / Int64ul
)
path_response = Struct(
    "path" / nixstr
)
paths_response = Struct(
    "paths" / construct.PrefixedArray(Int64ul, nixstr)
)
map_response = Struct(
    "entries" / construct.PrefixedArray(Int64ul, map_entry)
)
pathinfo_response = Struct(
    # daemon version 17 and above
    # "valid" / Int64ul,
    "deriver"/nixstr,
    "narHash"/nixstr,
    "references" / construct.PrefixedArray(Int64ul, nixstr),
    "registrationTime"/Int64ul,
    "narSize"/Int64ul,
    # daemon version 16 and above
    # "ultimate"/Int64ul,
    # "sigs" / construct.PrefixedArray(Int64ul, nixstr),
    # "ca"/nixstr,
)
wopCollectGarbage_response = Struct(
    "collectedPaths" / construct.PrefixedArray(Int64ul, nixstr),
    "bytesFreed"/Int64ul,
    # obsolete
    construct.Const(Int64ul, 0),
)
substitutable_pathinfo = Struct(
    "path"/nixstr,
    "deriver"/nixstr,
    "references"/construct.PrefixedArray(Int64ul, nixstr),
    "downloadSize"/Int64ul,
    "narSize"/Int64ul
)
wopQuerySubstitutablePathInfos_response = Struct(
    "infos" / construct.PrefixedArray(Int64ul, substitutable_pathinfo)
)
op_response = {
    "wopSetOptions": empty_response,
    "wopIsValidPath": int_response,
    "wopEnsurePath": int_response,
    "wopBuildPaths": int_response,
    "wopAddToStore": path_response,
    "wopAddTextToStore": path_response,
    "wopQueryPathInfo": pathinfo_response,
    "wopQueryReferrers": paths_response,
    "wopQueryDerivationOutputs": paths_response,
    "wopQuerySubstitutablePathInfos": wopQuerySubstitutablePathInfos_response,
    "wopAddTempRoot": int_response,
    "wopAddIndirectRoot": int_response,
    "wopFindRoots": map_response,
    "wopSyncWithGC": int_response,
    "wopCollectGarbage": wopCollectGarbage_response,
}

stderr_op_to_num = {
    "STDERR_NEXT": 0x6f6c6d67,
    "STDERR_READ": 0x64617461,
    "STDERR_WRITE": 0x64617416,
    "STDERR_LAST": 0x616c7473,
    "STDERR_ERROR": 0x63787470,
    "STDERR_START_ACTIVITY": 0x53545254,
    "STDERR_STOP_ACTIVITY": 0x53544f50,
    "STDERR_RESULT": 0x52534c54,
}
stderr_enum = construct.Enum(Int64ul, **stderr_op_to_num)
stderr_error = Struct(
    "error"/nixstr,
    "status"/Int64ul
)
logger_field_type_enum = construct.Enum(Int64ul,
    int=0,
    string=1
)
logger_field = construct.Select(
    Struct(
        "type"/Const(logger_field_type_enum, "int"),
        "number"/Int64ul
    ),
    Struct(
        "type"/Const(logger_field_type_enum, "string"),
        "number"/nixstr
))
activity_id = Int64ul
verbosity_level_to_dict = {
    "lvlError": 0,
    "lvlInfo": 1,
    "lvlTalkative": 2,
    "lvlChatty": 3,
    "lvlDebug": 4,
    "lvlVomit": 5,
}
verbosity_level_enum = construct.Enum(Int64ul, **verbosity_level_to_dict)
activity_type_to_dict = {
    "actUnknown": 0,
    "actCopyPath": 100,
    "actDownload": 101,
    "actRealise": 102,
    "actCopyPaths": 103,
    "actBuilds": 104,
    "actBuild": 105,
    "actOptimiseStore": 106,
    "actVerifyPaths": 107,
    "actSubstitute": 108,
    "actQueryPathInfo": 109,
}
activity_type_enum = construct.Enum(Int64ul, **activity_type_to_dict)
stderr_start_activity = Struct(
    "activity"/activity_id,
    "verbosity_level"/verbosity_level_enum,
    "activity_type"/activity_type_enum,
    "string"/nixstr,
    "fields"/construct.PrefixedArray(Int64ul, logger_field),
    "parent"/activity_id
)
stderr_stop_activity = Struct(
    "activity"/activity_id
)
result_type_to_dict = {
    "resFileLinked": 100,
    "resBuildLogLine": 101,
    "resUntrustedPath": 102,
    "resCorruptedPath": 103,
    "resSetPhase": 104,
    "resProgress": 105,
    "resSetExpected": 106,
}
result_type_enum = construct.Enum(Int64ul, **result_type_to_dict)
stderr_result = Struct(
    "activity"/activity_id,
    "result_type"/result_type_enum,
    "fields"/construct.PrefixedArray(Int64ul, logger_field),
)
type_to_stderr_packet = {
    "STDERR_WRITE": Struct("data"/nixstr),
    "STDERR_READ": Struct(),
    "STDERR_ERROR": stderr_error,
    "STDERR_NEXT": Struct("data"/nixstr),
    "STDERR_START_ACTIVITY": stderr_start_activity,
    "STDERR_STOP_ACTIVITY": stderr_stop_activity,
    "STDERR_RESULT": stderr_result,
    "STDERR_LAST": Struct(),
}

client_hello = Const(Int64ul, WORKER_MAGIC_1)
server_hello_ack = Struct(
    Const(Int64ul, WORKER_MAGIC_2),
    "server_version"/Int64ul
)
client_ack = Struct(
    "client_version"/Int64ul,
    "should_set_affinity"/Int64ul,
    "cpu_affinity"/construct.If(construct.this.should_set_affinity == 1, Int64ul),
    "reserve_space"/Int64ul,
)

class Callcc:
    def __init__(self, func):
        self.func = func

    @staticmethod
    def yield_up(value):
        return (yield value)

    def __await__(self):
        return self.yield_up(self.func)

def callcc(func):
    return Callcc(func)

def start(coroutine):
    def trampoline(value):
        try:
            f = coroutine.send(value)
        except StopIteration:
            return
        f(trampoline)
    trampoline(None)

class Channel:
    def __init__(self):
        self.cbs = []

    def send(self, value):
        cbs = self.cbs
        self.cbs = []
        for cb in cbs:
            cb(value)

    def register_callback(self, cb):
        self.cbs.append(cb)

    async def recv(self):
        return (await callcc(self.register_callback))

class DataPoller:
    def __init__(self, read):
        self._read = read
        self.buf = bytes()

    async def wait_for_more(self):
        self.buf += await self._read()

    def available(self):
        return self.buf

    def consume(self, n):
        self.buf = self.buf[n:]

class Future:
    def __init__(self):
        self.value = None
        self.been_set = False

    def set(self, value):
        if self.been_set:
            raise Exception("can't set future twice")
        self.value = value
        self.been_set = True

    def get(self):
        if not self.been_set:
            raise Exception("can't get value of unset future")
        return self.value

def parse_with_con(con, bytes):
    parsed = construct.Optional(Struct(
        "offset1"/construct.Tell,
        "value"/con,
        "offset2"/construct.Tell
    )).parse(bytes)
    if parsed is not None:
        size = parsed["offset2"] - parsed["offset1"]
        return parsed["value"], size
    else:
        return None, 0

class ConnectedClient:
    def __init__(self, read_con, write_con, server_version, client_configuration):
        self.read_con = read_con
        self.write_con = write_con
        self.server_version = server_version
        self.client_configuration = client_configuration

    async def _iter_stderr(self):
        "Iterate over stderr messages sent by the server while it processes some request."
        while True:
            stderr_packet_type = await self.read_con(stderr_enum)
            if stderr_packet_type == "STDERR_LAST":
                break
            stderr_packet = await self.read_con(type_to_stderr_packet[stderr_packet_type])
            yield stderr_packet_type, stderr_packet

    async def call(self, op, request):
        await self.write_con(op_enum, op)
        await self.write_con(op_request[op], request)
        # We can't (yet) return a value directly from an async generator.
        # We can use a future to bridge this gap: we return a tuple
        # containing the async generator as well as the getter from a
        # future; the async generator will put its return value in the
        # future when it is done.
        result = Future()
        async def iter_stderr():
            yield from self._iter_stderr()
            result.set(await self.read_con(op_response[op]))
        return iter_stderr(), result.get

def nix_client(read_con, write_con):
    async def hello():
        await write_con(client_hello, None)
        server_ack = await read_con(server_hello_ack)
        server_version = server_ack['server_version']
        async def connect_with(client_ack_data):
            await write_con(client_ack, client_ack_data)
            self = ConnectedClient(read_con, write_con, server_version, client_ack_data)
            result = Future()
            async def iter_stderr():
                yield from self._iter_stderr()
                result.set(self)
            return iter_stderr(), result.get
        return connect_with, server_version
    return hello

async def nix_server(impl_start, read_con, write_con):
    async def write_out_stderr(iter_stderr):
        async for typ, msg in iter_stderr:
            await write_con(stderr_enum, typ)
            await write_con(type_to_stderr_packet[typ], msg)
        await write_con(stderr_enum, "STDERR_LAST")
    await read_con(client_hello)
    impl_hello, server_version = await impl_start()
    await write_con(server_hello_ack, {"server_version":server_version})
    ack = await read_con(client_ack)
    iter_stderr, get_impl = await impl_hello(ack)
    await write_out_stderr(iter_stderr)
    impl = get_impl()
    while True:
        op = await read_con(op_enum)
        request = await read_con(op_request[op])
        iter_stderr, get_response = await impl.call(op, request)
        await write_out_stderr(iter_stderr)
        response = get_response()
        await write_con(op_response[op], response)

class PrintingConnectedClient:
    def __init__(self, client):
        self.client = client

    async def call(self, op, request):
        eprint(">", op, request)
        iter_stderr, get_result = await self.client.call(op, request)
        async def printing_iter_stderr():
            async for typ, msg in iter_stderr:
                eprint("<", typ, msg)
                yield typ, msg
        def printing_get_result():
            result = get_result()
            eprint("<", result)
            return result
        return printing_iter_stderr(), printing_get_result

def printing_nix_client(read, write):
    hello = nix_client(read, write)
    async def printing_hello():
        connect_with, server_version = await hello()
        eprint(f"< server connection response, version:{server_version:#0x}")
        async def printing_connect_with(ack):
            eprint(f"> client connection response, version:{ack['client_version']:#0x}, ", ack)
            iter_stderr, get_client = await connect_with(ack)
            async def printing_iter_stderr():
                async for typ, msg in iter_stderr:
                    eprint("<", typ, msg)
                    yield typ, msg
            def get_printing_client():
                return PrintingConnectedClient(get_client())
            return printing_iter_stderr(), get_printing_client
        return printing_connect_with, server_version
    return printing_hello

async def dummy_write(data):
    pass

def fd_reader(fd):
    async def read():
        buf = os.read(fd, 4096)
        if len(buf) == 0:
            raise Exception(f"got eof on {fd}")
        else:
            return buf
    return read

def fd_writer(fd):
    async def write(data):
        sent = os.write(fd, data)
        if sent != len(data):
            raise Exception(f"partial write to {fd}")
    return write

def con_reader(read):
    reader = DataPoller(read)
    async def read_con(con):
        while True:
            value, consumed = parse_with_con(con, reader.available())
            if value is not None:
                reader.consume(consumed)
                return value
            await reader.wait_for_more()
    return read_con

def con_writer(write):
    async def write_con(con, data):
        built = con.build(data)
        await write(built)
    return write_con

def tag_as(s, f):
    def wrapped(*args, **kwargs):
        eprint(s, args)
        return f(*args, **kwargs)
    # return wrapped
    return f

def just_dissect(sock):
    stdin_channel = Channel()
    sock_channel = Channel()
    start(nix_server(
        printing_nix_client(
            tag_as("sock in", con_reader(sock_channel.recv)),
            tag_as("sock out", con_writer(dummy_write))),
        tag_as("stdin", con_reader(stdin_channel.recv)),
        tag_as("stdout", con_writer(dummy_write))
    ))

    sel = selectors.DefaultSelector()
    
    sel.register(sock, selectors.EVENT_READ)
    sel.register(sys.stdin.buffer, selectors.EVENT_READ)

    while len(sel.get_map()) > 0:
        tuples = sel.select()
        for key, events in tuples:
            if key.fileobj is sock:
                data = sock.recv(4096)
                if len(data) == 0:
                    eprint("got eof on socket")
                    sel.unregister(sock)
                    sys.stdout.close()
                    continue
                sock_channel.send(data)
                sent = os.write(sys.stdout.buffer.fileno(), data)
                if sent != len(data):
                    raise Exception("partial send from sock to stdout")
            if key.fileobj is sys.stdin.buffer:
                data = os.read(sys.stdin.buffer.fileno(), 4096)
                if len(data) == 0:
                    eprint("got eof on stdin")
                    sel.unregister(sys.stdin.buffer)
                    sock.shutdown(socket.SHUT_WR)
                    continue
                stdin_channel.send(data)
                sent = sock.send(data)
                if sent != len(data):
                    raise Exception("partial send from stdin to sock")
    eprint("DONE\n")

def fully_proxy(sock):
    start(nix_server(
        printing_nix_client(
            tag_as("sock in", con_reader(fd_reader(sock.fileno()))),
            tag_as("sock out", con_writer(fd_writer(sock.fileno())))),
        tag_as("stdin", con_reader(fd_reader(sys.stdin.fileno()))),
        tag_as("stdout", con_writer(fd_writer(sys.stdout.fileno())))
    ))
    eprint("DONE\n")

def main():
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    server_address = "/nix/var/nix/daemon-socket/socket"
    sock.connect(server_address)

    # return just_dissect(sock)
    return fully_proxy(sock)

if __name__ == '__main__':
    main()

#!/usr/bin/env python3

import socket
import sys
import os
import selectors
import struct
import worker_protocol
from construct_async import con_reader, con_writer
from async import fd_reader, fd_writer, Channel, LinearVariable, start

def eprint(*args, **kwargs):
    kwargs['file'] = sys.stderr
    print(*args, **kwargs)

class ConnectedClient:
    def __init__(self, read_con, write_con, protocol, server_version, client_version, initial_options):
        self.read_con = read_con
        self.write_con = write_con
        self.proto = protocol
        self.server_version = server_version
        self.client_version = client_version
        self.initial_options = initial_options

    async def _iter_stderr(self):
        "Iterate over stderr messages sent by the server while it processes some request."
        while True:
            # TODO STDERR_ERROR needs to result in an error going back to the user, with no result.
            # perhaps an exception?
            stderr_type = await self.read_con(self.proto.stderr_type)
            if stderr_type == "STDERR_LAST":
                break
            stderr_message = await self.read_con(self.proto.stderr_message[stderr_type])
            yield stderr_type, stderr_message

    async def call(self, op, request):
        await self.write_con(self.proto.op_type, op)
        await self.write_con(self.proto.op_request[op], request)
        # We can't (yet) return a value directly from an async generator.
        # We can use a future to bridge this gap: we return a tuple
        # containing the async generator as well as the getter from a
        # future; the async generator will put its return value in the
        # future when it is done.
        result = LinearVariable()
        async def iter_stderr():
            async for val in self._iter_stderr():
                yield val
            result.set(await self.read_con(self.proto.op_response[op]))
        return iter_stderr(), result.get

async def nix_client(read_con, write_con):
    await write_con(worker_protocol.client_hello, None)
    server_version = await read_con(worker_protocol.server_hello_version)
    async def connect_with(client_version, initial_options):
        await write_con(worker_protocol.client_version, client_version)
        proto = worker_protocol.get_constructors_for_version(server_version, client_version)
        await write_con(proto.client_initial_options, initial_options)
        self = ConnectedClient(read_con, write_con, proto, server_version, client_version, initial_options)
        result = LinearVariable()
        async def iter_stderr():
            async for val in self._iter_stderr():
                yield val
            result.set(self)
        return iter_stderr(), result.get
    return connect_with, server_version

async def nix_server(impl_start, read_con, write_con):
    await read_con(worker_protocol.client_hello)
    impl_hello, server_version = await impl_start()
    await write_con(worker_protocol.server_hello_version, server_version)
    client_version = await read_con(worker_protocol.client_version)
    proto = worker_protocol.get_constructors_for_version(server_version, client_version)
    async def write_out_stderr(iter_stderr):
        async for typ, msg in iter_stderr:
            await write_con(proto.stderr_type, typ)
            await write_con(proto.stderr_message[typ], msg)
        await write_con(proto.stderr_type, "STDERR_LAST")
    initial_options = await read_con(proto.client_initial_options)
    iter_stderr, get_impl = await impl_hello(client_version, initial_options)
    await write_out_stderr(iter_stderr)
    impl = get_impl()
    while True:
        op = await read_con(proto.op_type)
        eprint("parsing", op)
        request = await read_con(proto.op_request[op])
        iter_stderr, get_response = await impl.call(op, request)
        await write_out_stderr(iter_stderr)
        response = get_response()
        await write_con(proto.op_response[op], response)

class PrintingConnectedClient:
    def __init__(self, client):
        self.client = client

    async def call(self, op, request):
        eprint(">", op, request)
        iter_stderr, get_result = await self.client.call(op, request)
        async def printing_iter_stderr():
            async for typ, msg in iter_stderr:
                eprint("<", typ, msg)
                yield typ, msg
        def printing_get_result():
            result = get_result()
            eprint("<", result)
            return result
        return printing_iter_stderr(), printing_get_result

async def printing_nix_client(read, write):
    connect_with, server_version = await nix_client(read, write)
    eprint(f"< server connection response, version:{server_version:#0x}")
    async def printing_connect_with(client_version, initial_options):
        eprint(f"> client connection response, version:{client_version:#0x}", initial_options)
        iter_stderr, get_client = await connect_with(client_version, initial_options)
        async def printing_iter_stderr():
            async for typ, msg in iter_stderr:
                eprint("<", typ, msg)
                yield typ, msg
        return printing_iter_stderr(), lambda: PrintingConnectedClient(get_client())
    return printing_connect_with, server_version

def tag_as(s, f):
    def wrapped(*args, **kwargs):
        eprint(s, args)
        return f(*args, **kwargs)
    # return wrapped
    return f

async def make_nix_client():
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    server_address = "/nix/var/nix/daemon-socket/socket"
    sock.connect(server_address)
    sock_in = tag_as("sock in", con_reader(fd_reader(sock)))
    sock_out = tag_as("sock out", con_writer(fd_writer(sock)))
    return (await printing_nix_client(sock_in, sock_out))
    # return (await nix_client(sock_in, sock_out))

def do_things():
    async def things():
        client_hello, server_version = await make_nix_client()
        client_init_stderr, get_client = await client_hello(0x114, {
            # TODO we should be able to just omit this...
            "cpu_affinity": 4,
        })
        async for typ, msg in client_init_stderr:
            eprint(typ, msg)
        client = get_client()
        async def perform_call(op, request):
            stderr, get_response = await client.call(op, request)
            async for typ, msg in stderr:
                # currently, the client is already printing it
                pass
            return get_response()
        response = await perform_call(
            "wopAddToStore", {
                "baseName": "neato",
                "fixed": 0,
                "recursive": 1,
                "hashType": "sha256",
                "nar": {
                    "type": b"regular",
                    "contents": b"amazing I did it",
                },
        })
    start(things())

def fully_proxy():
    start(nix_server(
        make_nix_client,
        tag_as("stdin", con_reader(fd_reader(sys.stdin))),
        tag_as("stdout", con_writer(fd_writer(sys.stdout)))
    ))
    eprint("DONE\n")

# TODO
# reimplement script using this "library"
# proper on-stack event loop
# proxying with actual functionality
# extract deps into another file

# check if there's a way to get a "Not enough bytes" exception from
# construct; otherwise with my current model, I'll just block forever
# when I mis-parse something, since I interpret all exceptions as "Not
# enough bytes"
def just_dissect():
    server_address = "/nix/var/nix/daemon-socket/socket"
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect(server_address)

    stdin_channel = Channel()
    sock_channel = Channel()
    async def dummy_write(data): pass
    async def make_nix_client():
        sock_in = tag_as("sock in", con_reader(sock_channel.recv))
        sock_out = tag_as("sock out", con_writer(dummy_write))
        return (await printing_nix_client(sock_in, sock_out))
        # return (await nix_client(sock_in, sock_out))

    start(nix_server(
        make_nix_client,
        tag_as("stdin", con_reader(stdin_channel.recv)),
        tag_as("stdout", con_writer(dummy_write))
    ))

    sel = selectors.DefaultSelector()
    
    sel.register(sock, selectors.EVENT_READ)
    sel.register(sys.stdin.buffer, selectors.EVENT_READ)

    while len(sel.get_map()) > 0:
        tuples = sel.select()
        for key, events in tuples:
            if key.fileobj is sock:
                data = sock.recv(4096)
                if len(data) == 0:
                    eprint("got eof on socket")
                    sel.unregister(sock)
                    sys.stdout.close()
                    continue
                sock_channel.send(data)
                sent = os.write(sys.stdout.buffer.fileno(), data)
                if sent != len(data):
                    raise Exception("partial send from sock to stdout")
            if key.fileobj is sys.stdin.buffer:
                data = os.read(sys.stdin.buffer.fileno(), 4096)
                if len(data) == 0:
                    eprint("got eof on stdin")
                    sel.unregister(sys.stdin.buffer)
                    sock.shutdown(socket.SHUT_WR)
                    continue
                stdin_channel.send(data)
                sent = sock.send(data)
                if sent != len(data):
                    raise Exception("partial send from stdin to sock")
    eprint("DONE\n")

def main():
    # return just_dissect()
    return fully_proxy()
    # return do_things()

if __name__ == '__main__':
    main()

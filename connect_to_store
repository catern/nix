#!/usr/bin/env python3

import socket
import sys
import os
import selectors
import struct
import worker_protocol
from construct_async import con_reader, con_writer
from async import fd_reader, fd_writer, Channel, LinearVariable, start, store_generator_return_value, agen_return

def eprint(*args, **kwargs):
    kwargs['file'] = sys.stderr
    print(*args, **kwargs)

class StderrError(Exception):
    def __init__(self, error, status):
        super().__init__(error)
        self.error = error
        self.status = status

class ConnectedClient:
    def __init__(self, read_con, write_con, protocol, server_version, client_version, initial_options):
        self.read_con = read_con
        self.write_con = write_con
        self.proto = protocol
        self.server_version = server_version
        self.client_version = client_version
        self.initial_options = initial_options

    async def _iter_stderr(self):
        "Iterate over stderr messages sent by the server while it processes some request."
        while True:
            stderr_type = await self.read_con(self.proto.stderr_type)
            if stderr_type == "STDERR_LAST":
                break
            stderr_message = await self.read_con(self.proto.stderr_message[stderr_type])
            if stderr_type == "STDERR_ERROR":
                raise StderrError(stderr_message['error'], stderr_message['status'])
            yield stderr_type, stderr_message

    @store_generator_return_value
    async def call(self, op, request):
        await self.write_con(self.proto.op_type, op)
        await self.write_con(self.proto.op_request[op], request)
        async for val in self._iter_stderr():
            yield val
        agen_return(await self.read_con(self.proto.op_response[op]))

async def nix_client(read_con, write_con):
    await write_con(worker_protocol.client_hello, None)
    server_version = await read_con(worker_protocol.server_hello_version)

    @store_generator_return_value
    async def connect_with(client_version, initial_options):
        await write_con(worker_protocol.client_version, client_version)
        proto = worker_protocol.get_constructors_for_version(server_version, client_version)
        await write_con(proto.client_initial_options, initial_options)
        client = ConnectedClient(read_con, write_con, proto, server_version, client_version, initial_options)
        async for val in client._iter_stderr():
            yield val
        agen_return(client)
    return connect_with, server_version

async def nix_server(impl_start, read_con, write_con):
    await read_con(worker_protocol.client_hello)
    impl_hello, server_version = await impl_start()
    await write_con(worker_protocol.server_hello_version, server_version)
    client_version = await read_con(worker_protocol.client_version)
    proto = worker_protocol.get_constructors_for_version(server_version, client_version)
    async def write_out_stderr(stderr_with_value):
        try:
            async for typ, msg in stderr_with_value:
                await write_con(proto.stderr_type, typ)
                await write_con(proto.stderr_message[typ], msg)
        except StderrError as e:
            await write_con(proto.stderr_type, "STDERR_ERROR")
            await write_con(proto.stderr_message["STDERR_ERROR"], {"error":e.error, "status":e.status})
            raise
        await write_con(proto.stderr_type, "STDERR_LAST")
        return stderr_with_value.get()
    initial_options = await read_con(proto.client_initial_options)
    impl = await write_out_stderr(impl_hello(client_version, initial_options))
    while True:
        op = await read_con(proto.op_type)
        eprint("parsing", op)
        request = await read_con(proto.op_request[op])
        response = await write_out_stderr(impl.call(op, request))
        await write_con(proto.op_response[op], response)

import reprlib
import construct
class PrintingConnectedClient:
    def __init__(self, client):
        self.client = client

    @store_generator_return_value
    async def call(self, op, request):
        if isinstance(request, construct.lib.container.Container):
            eprint(">", op, request)
        else:
            eprint(">", op, reprlib.repr(request))
        stderr_with_response = self.client.call(op, request)
        try:
            async for typ, msg in stderr_with_response:
                eprint("<", typ, msg)
                yield typ, msg
        except StderrError as e:
            eprint(f"< ERROR({e.status}): {e.error}")
            raise
        response = stderr_with_response.get()
        eprint("<", response)
        agen_return(response)

async def printing_nix_client(read, write):
    connect_with, server_version = await nix_client(read, write)
    eprint(f"< server connection response, version:{server_version:#0x}")

    @store_generator_return_value
    async def printing_connect_with(client_version, initial_options):
        eprint(f"> client connection response, version:{client_version:#0x}", initial_options)
        stderr_with_client = connect_with(client_version, initial_options)
        try:
            async for typ, msg in stderr_with_client:
                eprint("<", typ, msg)
                yield typ, msg
        except StderrError as e:
            eprint(f"< LOGIN ERROR({e.status}): {e.error}")
            raise
        eprint("== Connection initialized.")
        agen_return(PrintingConnectedClient(stderr_with_client.get()))
    return printing_connect_with, server_version

def tag_as(s, f):
    def wrapped(*args, **kwargs):
        eprint(s, args)
        return f(*args, **kwargs)
    # return wrapped
    return f

async def make_nix_client():
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    server_address = "/nix/var/nix/daemon-socket/socket"
    sock.connect(server_address)
    sock_in = tag_as("sock in", con_reader(fd_reader(sock)))
    sock_out = tag_as("sock out", con_writer(fd_writer(sock)))
    return (await printing_nix_client(sock_in, sock_out))
    # return (await nix_client(sock_in, sock_out))


from collections import namedtuple
from pathlib import Path

DerivationOutput = namedtuple('DerivationOutput', ['path', 'hashAlgo', 'hash'])

Derivation = namedtuple('Derivation', ['outputs', 'inputs', 'inputSrcs', 'platform', 'builder', 'args', 'env'])

def build_derivation(outputs, inputs, inputSrcs, platform, builder, args, env):
    return Derivation(
        {output[0]:DerivationOutput(Path(output[1]), output[2], output[3]) for output in outputs},
        {Path(input[0]):input[1] for input in inputs},
        inputSrcs,
        platform,
        builder,
        args,
        dict(env)
    )

def parse_derivation(s):
    # LOL
    return eval(s, {'Derive':build_derivation})

import urllib.request
def fetchurl(url):
    return urllib.request.urlopen(url).read()

def add_to_store(path, hashType, recursive):
    if recursive:
        subprocess.check_call(['nix-store', '--add-fixed', '--recursive', hashType, path])
    else:
        subprocess.check_call(['nix-store', '--add-fixed', hashType, path])

def read_path_as_nar(path):
    if path.is_dir():
        return {
            "type": b"directory",
            "entries": [{"name": child.name.encode(), "node": read_path_as_nar(child)}
                        for child in path.iterdir()],
        }
    elif path.is_symlink():
        return {
            "type": b"symlink",
            "target": os.readlink(path),
        }
    elif path.is_file():
        executable = bool(path.stat().st_mode & 0o111)
        return {
            "type": b"regular",
            "flag": b"executable" if executable else b"",
            "contents": bytes(path),
        }
    else:
        raise Exception("this path is of a type that can't be read as a NAR")

@store_generator_return_value
async def impure_build_nonbuiltin(drv):
    "Returns a NAR-dict containing the file/folder"
    import tempfile
    import subprocess
    import shutil
    fake_outdir = Path(tempfile.mkdtemp())
    fake_out = fake_outdir/"out"
    workdir = Path(tempfile.mkdtemp())

    env = os.environ.copy()
    env.update(drv.env)
    env.update({'NIX_BUILD_TOP': workdir, 'out': fake_out, 'TMPDIR': workdir})
    cmdline = [drv.builder] + drv.args
    yield "STDERR_NEXT", {"data":f"Starting impure builder: {cmdline}"}
    proc = subprocess.Popen(cmdline, cwd=workdir, env=env, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
    if proc.wait() != 0:
        raise StderrError("Impure builder exited", 1)
    nar = read_path_as_nar(fake_out)
    shutil.rmtree(workdir)
    shutil.rmtree(fake_outdir)
    agen_return(nar)

class ImpureClient:
    def __init__(self, client):
        self.client = client

    @classmethod
    async def make(cls, make=make_nix_client):
        connect_with, server_version = await make()
        @store_generator_return_value
        async def my_connect_with(client_version, initial_options):
            stderr_with_client = connect_with(client_version, initial_options)
            async for typ, msg in stderr_with_client:
                yield typ, msg
            agen_return(cls(stderr_with_client.get()))
        return my_connect_with, server_version

    # TODO I should really log exactly what I get from the client.
    # Maybe I should have two PrintingClients, one before ImpureClient, one after.
    def call(self, op, request):
        if op == 'wopBuildPaths':
            return self.impure_build_paths(request)
        else:
            return self.client.call(op, request)

    @store_generator_return_value
    async def impure_build_paths(self, request):
        # TODO handle building multiple paths
        if len(request.paths) != 1 or request.mode != 0:
            # in an ideal world, this would be just "return (yield from call(stuff))"
            stderr_with_response = self.client.call("wopBuildPaths", request)
            for msg in stderr_with_response:
                yield msg
            agen_return(stderr_with_response.get())
        else:
            path, output = request.paths[0].split('!', 1)
            path = Path(path)
            # if path.exists():
            #     eprint("not building because it's already there")
            #     agen_return({"ret": 1})
            drv = parse_derivation(path.read_text())
            # TODO handle building non-builtins
            stderr_with_response = self.impure_build(drv)
            async for msg in stderr_with_response:
                yield msg
            agen_return(stderr_with_response.get())

    def add_nar_to_store(self, name, hashType, recursive, nar):
        return self.client.call(
            "wopAddToStore", {
                "baseName": name,
                "fixed": not (hashType == 'sha256' and recursive),
                "recursive": recursive,
                "hashType": hashType,
                "nar": nar,
        })

    def add_bytes_to_store(self, name, hashType, recursive, bytes):
        return self.add_nar_to_store(name, hashType, recursive, {
            "type": b"regular",
            "contents": bytes,
        })
        
    @store_generator_return_value
    async def impure_build(self, drv):
        "Impurely build this derivation in the current environment and add it to the store."
        output = drv.outputs['out']
        if not output.hash:
            raise StderrError("only fixed output derivations can be build impurely", 1)
        if not len(drv.outputs) == 1:
            raise StderrError("fixed output derivations must only have one output", 1)
        if not all(input.exists() for input in drv.inputs):
            raise StderrError("all inputs must be valid before building", 1)
    
        yield "STDERR_NEXT", {"data":"starting impure build"}
        name = str(output.path).split('-', 1)[1]
        if ":" in output.hashAlgo:
            option, hashType = output.hashAlgo.split(':')
            if option == 'r':
                recursive = True
            else:
                raise StderrError(f"unknown option {option}", 1)
        else:
            hashType = output.hashAlgo
            recursive = False
    
        if drv.builder == 'builtin:fetchurl':
            nar = {
                "type": b"regular",
                "contents": fetchurl(drv.env['url']),
            }
        else:
            # TODO finish this guy!!!
            stderr_nar = impure_build_nonbuiltin(drv)
            async for msg in stderr_nar:
                yield msg
            nar = stderr_nar.get()
        async for msg in self.add_nar_to_store(name, hashType, recursive, nar):
            yield msg
        agen_return({"ret": 1})

    async def build_paths(self, drvs):
        # TODO set up a reactive build graph
        for drv in drvs:
            if drv.outputs['out'].hash:
                await self.impure_build(drv)
        return 1

def do_things(path):
    import nar
    eprint(nar.dump.parse(nar.dump.build(read_path_as_nar(path))))
    return

def fully_proxy():
    start(nix_server(
        ImpureClient.make,
        tag_as("stdin", con_reader(fd_reader(sys.stdin))),
        tag_as("stdout", con_writer(fd_writer(sys.stdout)))
    ))
    eprint("DONE\n")

# TODO
# reimplement script using this "library"
# proper on-stack event loop
# proxying with actual functionality
# extract deps into another file

# check if there's a way to get a "Not enough bytes" exception from
# construct; otherwise with my current model, I'll just block forever
# when I mis-parse something, since I interpret all exceptions as "Not
# enough bytes"
def just_dissect():
    server_address = "/nix/var/nix/daemon-socket/socket"
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect(server_address)

    stdin_channel = Channel()
    sock_channel = Channel()
    async def dummy_write(data): pass
    async def make_nix_client():
        sock_in = tag_as("sock in", con_reader(sock_channel.recv))
        sock_out = tag_as("sock out", con_writer(dummy_write))
        return (await printing_nix_client(sock_in, sock_out))
        # return (await nix_client(sock_in, sock_out))

    start(nix_server(
        make_nix_client,
        tag_as("stdin", con_reader(stdin_channel.recv)),
        tag_as("stdout", con_writer(dummy_write))
    ))

    sel = selectors.DefaultSelector()
    
    sel.register(sock, selectors.EVENT_READ)
    sel.register(sys.stdin.buffer, selectors.EVENT_READ)

    while len(sel.get_map()) > 0:
        tuples = sel.select()
        for key, events in tuples:
            if key.fileobj is sock:
                data = sock.recv(4096)
                if len(data) == 0:
                    eprint("got eof on socket")
                    sel.unregister(sock)
                    sys.stdout.close()
                    continue
                sock_channel.send(data)
                sent = os.write(sys.stdout.buffer.fileno(), data)
                if sent != len(data):
                    raise Exception("partial send from sock to stdout")
            if key.fileobj is sys.stdin.buffer:
                data = os.read(sys.stdin.buffer.fileno(), 4096)
                if len(data) == 0:
                    eprint("got eof on stdin")
                    sel.unregister(sys.stdin.buffer)
                    sock.shutdown(socket.SHUT_WR)
                    continue
                stdin_channel.send(data)
                sent = sock.send(data)
                if sent != len(data):
                    raise Exception("partial send from stdin to sock")
    eprint("DONE\n")

def main():
    import sys

    if len(sys.argv) > 1:
        return do_things(Path(sys.argv[1]))
    else:
        return fully_proxy()
        # return just_dissect()

if __name__ == '__main__':
    main()

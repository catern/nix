#!/usr/bin/env python3

import socket
import sys
import os
import selectors
import struct
import worker_protocol
from construct_async import con_reader, con_writer
from async import fd_reader, fd_writer, Channel, LinearVariable, start, store_generator_return_value, agen_return

def eprint(*args, **kwargs):
    kwargs['file'] = sys.stderr
    print(*args, **kwargs)

class StderrError(Exception):
    def __init__(self, error, status):
        super().__init__(error)
        self.error = error
        self.status = status

class ConnectedClient:
    def __init__(self, read_con, write_con, protocol, server_version, client_version, initial_options):
        self.read_con = read_con
        self.write_con = write_con
        self.proto = protocol
        self.server_version = server_version
        self.client_version = client_version
        self.initial_options = initial_options

    async def _iter_stderr(self):
        "Iterate over stderr messages sent by the server while it processes some request."
        while True:
            stderr_type = await self.read_con(self.proto.stderr_type)
            if stderr_type == "STDERR_LAST":
                break
            stderr_message = await self.read_con(self.proto.stderr_message[stderr_type])
            if stderr_type == "STDERR_ERROR":
                raise StderrError(stderr_message['error'], stderr_message['status'])
            yield stderr_type, stderr_message

    @store_generator_return_value
    async def call(self, op, request):
        await self.write_con(self.proto.op_type, op)
        await self.write_con(self.proto.op_request[op], request)
        async for val in self._iter_stderr():
            yield val
        agen_return(await self.read_con(self.proto.op_response[op]))

async def nix_client(read_con, write_con):
    await write_con(worker_protocol.client_hello, None)
    server_version = await read_con(worker_protocol.server_hello_version)

    @store_generator_return_value
    async def connect_with(client_version, initial_options):
        await write_con(worker_protocol.client_version, client_version)
        proto = worker_protocol.get_constructors_for_version(server_version, client_version)
        await write_con(proto.client_initial_options, initial_options)
        client = ConnectedClient(read_con, write_con, proto, server_version, client_version, initial_options)
        async for val in client._iter_stderr():
            yield val
        agen_return(client)
    return connect_with, server_version

async def nix_server(impl_start, read_con, write_con):
    await read_con(worker_protocol.client_hello)
    impl_hello, server_version = await impl_start()
    await write_con(worker_protocol.server_hello_version, server_version)
    client_version = await read_con(worker_protocol.client_version)
    proto = worker_protocol.get_constructors_for_version(server_version, client_version)
    async def write_out_stderr(stderr_with_value):
        try:
            async for typ, msg in stderr_with_value:
                await write_con(proto.stderr_type, typ)
                await write_con(proto.stderr_message[typ], msg)
        except StderrError as e:
            await write_con(proto.stderr_type, "STDERR_ERROR")
            await write_con(proto.stderr_message["STDERR_ERROR"], {"error":e.error, "status":e.status})
            raise
        await write_con(proto.stderr_type, "STDERR_LAST")
        return stderr_with_value.get()
    initial_options = await read_con(proto.client_initial_options)
    impl = await write_out_stderr(impl_hello(client_version, initial_options))
    while True:
        op = await read_con(proto.op_type)
        eprint("parsing", op)
        request = await read_con(proto.op_request[op])
        response = await write_out_stderr(impl.call(op, request))
        await write_con(proto.op_response[op], response)

import reprlib
import construct
class PrintingConnectedClient:
    def __init__(self, client):
        self.client = client

    @store_generator_return_value
    async def call(self, op, request):
        if isinstance(request, construct.lib.container.Container):
            eprint(">", op, request)
        else:
            eprint(">", op, reprlib.repr(request))
        stderr_with_response = self.client.call(op, request)
        try:
            async for typ, msg in stderr_with_response:
                eprint("<", typ, msg)
                yield typ, msg
        except StderrError as e:
            eprint(f"< ERROR({e.status}): {e.error}")
            raise
        response = stderr_with_response.get()
        eprint("<", response)
        agen_return(response)

async def printing_nix_client(read, write):
    connect_with, server_version = await nix_client(read, write)
    eprint(f"< server connection response, version:{server_version:#0x}")

    @store_generator_return_value
    async def printing_connect_with(client_version, initial_options):
        eprint(f"> client connection response, version:{client_version:#0x}", initial_options)
        stderr_with_client = connect_with(client_version, initial_options)
        try:
            async for typ, msg in stderr_with_client:
                eprint("<", typ, msg)
                yield typ, msg
        except StderrError as e:
            eprint(f"< LOGIN ERROR({e.status}): {e.error}")
            raise
        eprint("== Connection initialized.")
        agen_return(PrintingConnectedClient(stderr_with_client.get()))
    return printing_connect_with, server_version

def tag_as(s, f):
    def wrapped(*args, **kwargs):
        eprint(s, args)
        return f(*args, **kwargs)
    # return wrapped
    return f

async def make_nix_client():
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    server_address = "/nix/var/nix/daemon-socket/socket"
    sock.connect(server_address)
    sock_in = tag_as("sock in", con_reader(fd_reader(sock)))
    sock_out = tag_as("sock out", con_writer(fd_writer(sock)))
    return (await printing_nix_client(sock_in, sock_out))
    # return (await nix_client(sock_in, sock_out))


from collections import namedtuple
from pathlib import Path

DerivationOutput = namedtuple('DerivationOutput', ['path', 'hashAlgo', 'hash'])

Derivation = namedtuple('Derivation', ['outputs', 'inputs', 'inputSrcs', 'platform', 'builder', 'args', 'env'])

def build_derivation(outputs, inputs, inputSrcs, platform, builder, args, env):
    return Derivation(
        {output[0]:DerivationOutput(Path(output[1]), output[2], output[3]) for output in outputs},
        {Path(input[0]):input[1] for input in inputs},
        inputSrcs,
        platform,
        builder,
        args,
        dict(env)
    )

def parse_derivation(s):
    # LOL
    return eval(s, {'Derive':build_derivation})

import urllib.request
def fetchurl(url):
    return urllib.request.urlopen(url).read()

def add_to_store(path, hashType, recursive):
    if recursive:
        subprocess.check_call(['nix-store', '--add-fixed', '--recursive', hashType, path])
    else:
        subprocess.check_call(['nix-store', '--add-fixed', hashType, path])

class ImpureClient:
    def __init__(self, client):
        self.client = client

    def call(self, op, request):
        if op == 'wopBuildPaths':
            return self.impure_build_paths(request)
        else:
            return self.client.call(op, request)

    def with_no_logs(self, retval):
        return no_logs(), lambda: retval

    @store_generator_return_value
    async def impure_build_paths(self, request):
        eprint("Impurely building", request)
        # TODO handle building multiple paths
        if len(request.paths) != 1 or request.mode != 0:
            # in an ideal world, this would be just "return (yield from call(stuff))"
            stderr_with_response = self.client.call("wopBuildPaths", request)
            for msg in stderr_with_response:
                yield msg
            agen_return(stderr_with_response.get())
        else:
            path, output = request.paths[0].split('!', 1)
            path = Path(path)
            # if path.exists():
            #     eprint("not building because it's already there")
            #     agen_return({"ret": 1})
            drv = parse_derivation(path.read_text())
            # TODO handle building non-builtins
            await self.impure_build(drv)
            agen_return({"ret": 1})

    async def perform_call(self, op, request):
        stderr_with_response = self.client.call(op, request)
        async for typ, msg in stderr_with_response:
            # currently, the client is already printing it
            pass
        return stderr_with_response.get()

    async def add_nar_to_store(self, name, hashType, recursive, nar):
        return (await self.perform_call(
            "wopAddToStore", {
                "baseName": name,
                "fixed": not (hashType == 'sha256' and recursive),
                "recursive": recursive,
                "hashType": hashType,
                "nar": nar,
        }))

    async def add_bytes_to_store(self, name, hashType, recursive, bytes):
        return (await self.add_nar_to_store(name, hashType, recursive, {
            "type": b"regular",
            "contents": bytes,
        }))

    @classmethod
    async def make(cls):
        client_hello, server_version = await make_nix_client()
        client_init_stderr, get_client = await client_hello(0x114, {
            # TODO we should be able to just omit this...
            "cpu_affinity": 4,
        })
        async for typ, msg in client_init_stderr:
            eprint(typ, msg)
        return cls(get_client())

    @classmethod
    async def make(cls, make=make_nix_client):
        connect_with, server_version = await make()
        @store_generator_return_value
        async def my_connect_with(client_version, initial_options):
            stderr_with_client = connect_with(client_version, initial_options)
            async for typ, msg in stderr_with_client:
                yield typ, msg
            agen_return(cls(stderr_with_client.get()))
        return my_connect_with, server_version

    async def impure_build(self, drv):
        "Impurely build this derivation in the current environment and add it to the store."
        output = drv.outputs['out']
        if not output.hash:
            raise Exception("only fixed output derivations can be build impurely")
        if not len(drv.outputs) == 1:
            raise Exception("fixed output derivations must only have one output")
        if not all(input.exists() for input in drv.inputs):
            raise Exception("all inputs must be valid before building")
    
        name = str(output.path).split('-', 1)[1]
        if ":" in output.hashAlgo:
            option, hashType = output.hashAlgo.split(':')
            if option == 'r':
                recursive = True
            else:
                raise Exception("unknown option", option)
        else:
            hashType = output.hashAlgo
            recursive = False
    
        if drv.builder == 'builtin:fetchurl':
            return (await self.add_bytes_to_store(name, hashType, recursive, fetchurl(drv.env['url'])))
        else:
            # TODO handle building non-builtins
            raise Exception("currently only works for builtin:fetchurl")

    async def build_paths(self, drvs):
        # TODO set up a reactive build graph
        for drv in drvs:
            if drv.outputs['out'].hash:
                await self.impure_build(drv)
        return 1

def impure_build_nonbuiltin(drv):
    import tempfile
    import subprocess
    import shutil
    fake_out = Path(tempfile.mkdtemp())
    workdir = Path(tempfile.mkdtemp())

    env = os.environ.copy()
    env.update(drv.env)
    env.update({'NIX_BUILD_TOP': workdir, 'out': fake_out, 'TMPDIR': workdir})
    cmdline = [drv.builder] + drv.args
    proc = subprocess.Popen(cmdline, cwd=workdir, env=env)
    if proc.wait() != 0:
        raise Exception
    shutil.rmtree(workdir)
    return fake_out

def do_things(path):
    # need to query derivation info.
    # or maybe I just read it and build it?
    # yeah that seems right

    # no no
    # hmm
    # should I read first?
    # or check first?

    # I suppose I should wopQueryMissing first, and see which of them is missing.

    # oh wait, in any case I need to read the drv to find out if it's a fixout.

    # okay, so I'll read the drv,
    with path.open() as f:
        drv = parse_derivation(f.read())
    eprint(drv)
    # check for whether its output exists (by just checking the filesystem lmao)
    if drv.outputs['out'].path.exists():
        eprint("already exists")
        print(drv.outputs['out'].path)
        # return
    # build it impurely,
    eprint("building")
    async def do_stuff():
        client = await ImpureClient.make()
        return (await client.impure_build(drv))

    result = LinearVariable()
    start(do_stuff(), result.set)
    eprint("result", result.get())
    return

    # later i'll handle recursing and building its inputs
    async def things():
        client_hello, server_version = await make_nix_client()
        client_init_stderr, get_client = await client_hello(0x114, {
            # TODO we should be able to just omit this...
            "cpu_affinity": 4,
        })
        async for typ, msg in client_init_stderr:
            eprint(typ, msg)
        client = get_client()
        async def perform_call(op, request):
            stderr, get_response = await client.call(op, request)
            async for typ, msg in stderr:
                # currently, the client is already printing it
                pass
            return get_response()
        response = await perform_call(
            "wopAddToStore", {
                "baseName": "neato",
                "fixed": 0,
                "recursive": 1,
                "hashType": "sha256",
                "nar": {
                    "type": b"regular",
                    "contents": b"amazing I did it",
                },
        })
    start(things())

def fully_proxy():
    start(nix_server(
        ImpureClient.make,
        tag_as("stdin", con_reader(fd_reader(sys.stdin))),
        tag_as("stdout", con_writer(fd_writer(sys.stdout)))
    ))
    eprint("DONE\n")

# TODO
# reimplement script using this "library"
# proper on-stack event loop
# proxying with actual functionality
# extract deps into another file

# check if there's a way to get a "Not enough bytes" exception from
# construct; otherwise with my current model, I'll just block forever
# when I mis-parse something, since I interpret all exceptions as "Not
# enough bytes"
def just_dissect():
    server_address = "/nix/var/nix/daemon-socket/socket"
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect(server_address)

    stdin_channel = Channel()
    sock_channel = Channel()
    async def dummy_write(data): pass
    async def make_nix_client():
        sock_in = tag_as("sock in", con_reader(sock_channel.recv))
        sock_out = tag_as("sock out", con_writer(dummy_write))
        return (await printing_nix_client(sock_in, sock_out))
        # return (await nix_client(sock_in, sock_out))

    start(nix_server(
        make_nix_client,
        tag_as("stdin", con_reader(stdin_channel.recv)),
        tag_as("stdout", con_writer(dummy_write))
    ))

    sel = selectors.DefaultSelector()
    
    sel.register(sock, selectors.EVENT_READ)
    sel.register(sys.stdin.buffer, selectors.EVENT_READ)

    while len(sel.get_map()) > 0:
        tuples = sel.select()
        for key, events in tuples:
            if key.fileobj is sock:
                data = sock.recv(4096)
                if len(data) == 0:
                    eprint("got eof on socket")
                    sel.unregister(sock)
                    sys.stdout.close()
                    continue
                sock_channel.send(data)
                sent = os.write(sys.stdout.buffer.fileno(), data)
                if sent != len(data):
                    raise Exception("partial send from sock to stdout")
            if key.fileobj is sys.stdin.buffer:
                data = os.read(sys.stdin.buffer.fileno(), 4096)
                if len(data) == 0:
                    eprint("got eof on stdin")
                    sel.unregister(sys.stdin.buffer)
                    sock.shutdown(socket.SHUT_WR)
                    continue
                stdin_channel.send(data)
                sent = sock.send(data)
                if sent != len(data):
                    raise Exception("partial send from stdin to sock")
    eprint("DONE\n")

def main():
    import sys

    if len(sys.argv) > 1:
        return do_things(Path(sys.argv[1]))
    else:
        return fully_proxy()
        # return just_dissect()

if __name__ == '__main__':
    main()

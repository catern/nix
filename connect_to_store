#!/usr/bin/env python3

import socket
import sys
import os
import selectors
import struct

import nar
import construct
from construct import Struct, Const, Int64ul, Pass

def eprint(*args, **kwargs):
    kwargs['file'] = sys.stderr
    print(*args, **kwargs)

WORKER_MAGIC_1 = 0x6e697863
WORKER_MAGIC_2 = 0x6478696f
stderr_op_to_num = {
    "STDERR_NEXT": 0x6f6c6d67,
    "STDERR_READ": 0x64617461,
    "STDERR_WRITE": 0x64617416,
    "STDERR_LAST": 0x616c7473,
    "STDERR_ERROR": 0x63787470,
    "STDERR_START_ACTIVITY": 0x53545254,
    "STDERR_STOP_ACTIVITY": 0x53544f50,
    "STDERR_RESULT": 0x52534c54,
}
wop_to_num = {
    "wopIsValidPath": 1,
    "wopHasSubstitutes": 3,
    "wopQueryPathHash": 4,
    "wopQueryReferences": 5,
    "wopQueryReferrers": 6,
    "wopAddToStore": 7,
    "wopAddTextToStore": 8,
    "wopBuildPaths": 9,
    "wopEnsurePath": 10,
    "wopAddTempRoot": 11,
    "wopAddIndirectRoot": 12,
    "wopSyncWithGC": 13,
    "wopFindRoots": 14,
    "wopExportPath": 16,
    "wopQueryDeriver": 18,
    "wopSetOptions": 19,
    "wopCollectGarbage": 20,
    "wopQuerySubstitutablePathInfo": 21,
    "wopQueryDerivationOutputs": 22,
    "wopQueryAllValidPaths": 23,
    "wopQueryFailedPaths": 24,
    "wopClearFailedPaths": 25,
    "wopQueryPathInfo": 26,
    "wopImportPaths": 27,
    "wopQueryDerivationOutputNames": 28,
    "wopQueryPathFromHashPart": 29,
    "wopQuerySubstitutablePathInfos": 30,
    "wopQueryValidPaths": 31,
    "wopQuerySubstitutablePaths": 32,
    "wopQueryValidDerivers": 33,
    "wopOptimiseStore": 34,
    "wopVerifyStore": 35,
    "wopBuildDerivation": 36,
    "wopAddSignatures": 37,
    "wopNarFromPath": 38,
    "wopAddToStoreNar": 39,
    "wopQueryMissing": 40,
}
nixstr = construct.Aligned(8, construct.PascalString(construct.Int64ul, encoding="utf8"))
wop_enum = construct.Enum(Int64ul, **wop_to_num)
stderr_enum = construct.Enum(Int64ul, **stderr_op_to_num)
wopSetOptions = Struct(
    "keepFailed" / Int64ul,
    "keepGoing" / Int64ul,
    "tryFallback" / Int64ul,
    "verbosity" / Int64ul,
    "maxBuildJobs" / Int64ul,
    "maxSilentTime" / Int64ul,
    "useBuildHook" / Int64ul,
    "verboseBuild" / Int64ul,
    "logType" / Int64ul,
    "printBuildTrace" / Int64ul,
    "buildCores" / Int64ul,
    "useSubstitutes" / Int64ul,
    "overrides" / construct.PrefixedArray(Int64ul, Struct(
        "option" / nixstr,
        "value" / nixstr
    ))
)
wopAddToStore = Struct(
    "baseName" / nixstr,
    "fixed" / Int64ul,
    "recursive" / Int64ul,
    "hashType" / nixstr,
    "nar" / nar.dump
)
wopAddTextToStore = Struct(
    "baseName" / nixstr,
    "string" / nixstr,
    "references" / construct.PrefixedArray(Int64ul, nixstr)
)
wopBuildPaths = Struct(
    "paths" / construct.PrefixedArray(Int64ul, nixstr),
    "mode" / Int64ul
)
wopQuerySubstitutablePathInfos = Struct(
    "paths" / construct.PrefixedArray(Int64ul, nixstr),
)
gc_action_to_num = {
    "gcReturnLive": 0,
    "gcReturnDead": 1,
    "gcDeleteDead": 2,
    "gcDeleteSpecific": 3,
}
gc_action_enum = construct.Enum(Int64ul, **gc_action_to_num)
wopCollectGarbage = Struct(
    "action" / gc_action_enum,
    "pathsToDelete" / construct.PrefixedArray(Int64ul, nixstr),
    "ignoreLiveness" / Int64ul,
    "maxFreed" / Int64ul,
    # obselete fields
    Int64ul,
    Int64ul,
    Int64ul
)
op_request = {
    "wopSetOptions":wopSetOptions,
    "wopAddToStore":wopAddToStore,
    "wopAddTextToStore":wopAddTextToStore,
    "wopIsValidPath": Struct("path"/nixstr),
    "wopEnsurePath": Struct("path"/nixstr),
    "wopBuildPaths":wopBuildPaths,
    "wopQueryPathInfo": Struct("path"/nixstr),
    "wopQueryReferrers": Struct("path"/nixstr),
    "wopQueryDerivationOutputs": Struct("path"/nixstr),
    "wopQuerySubstitutablePathInfos":wopQuerySubstitutablePathInfos,
    "wopAddTempRoot": Struct("path"/nixstr),
    "wopAddIndirectRoot": Struct("path"/nixstr),
    "wopFindRoots": Struct(),
    "wopSyncWithGC": Struct(),
    "wopCollectGarbage":wopCollectGarbage,
}
operation = Struct(
    "type" / wop_enum,
    construct.Embedded(construct.Switch(construct.this.type, op_request))
)

num_to_wop = { num:wop for (wop, num) in wop_to_num.items() }

def must_equal(a, b):
    if a != b:
        raise Exception("protocol error:", a, "!=", b)

map_entry = Struct(
    "key" / nixstr,
    "value" / nixstr
)
empty_response = Struct(
)
int_response = Struct(
    "ret" / Int64ul
)
path_response = Struct(
    "path" / nixstr
)
paths_response = Struct(
    "paths" / construct.PrefixedArray(Int64ul, nixstr)
)
map_response = Struct(
    "entries" / construct.PrefixedArray(Int64ul, map_entry)
)
pathinfo_response = Struct(
    # daemon version 17 and above
    # "valid" / Int64ul,
    "deriver"/nixstr,
    "narHash"/nixstr,
    "references" / construct.PrefixedArray(Int64ul, nixstr),
    "registrationTime"/Int64ul,
    "narSize"/Int64ul,
    # daemon version 16 and above
    # "ultimate"/Int64ul,
    # "sigs" / construct.PrefixedArray(Int64ul, nixstr),
    # "ca"/nixstr,
)
wopCollectGarbage_response = Struct(
    "collectedPaths" / construct.PrefixedArray(Int64ul, nixstr),
    "bytesFreed"/Int64ul,
    # obsolete
    Int64ul,
)
substitutable_pathinfo = Struct(
    "path"/nixstr,
    "deriver"/nixstr,
    "references"/construct.PrefixedArray(Int64ul, nixstr),
    "downloadSize"/Int64ul,
    "narSize"/Int64ul
)
wopQuerySubstitutablePathInfos_response = Struct(
    "infos" / construct.PrefixedArray(Int64ul, substitutable_pathinfo)
)
op_response = {
    "wopSetOptions": empty_response,
    "wopIsValidPath": int_response,
    "wopEnsurePath": int_response,
    "wopBuildPaths": int_response,
    "wopAddToStore": path_response,
    "wopAddTextToStore": path_response,
    "wopQueryPathInfo": pathinfo_response,
    "wopQueryReferrers": paths_response,
    "wopQueryDerivationOutputs": paths_response,
    "wopQuerySubstitutablePathInfos": wopQuerySubstitutablePathInfos_response,
    "wopAddTempRoot": int_response,
    "wopAddIndirectRoot": int_response,
    "wopFindRoots": map_response,
    "wopSyncWithGC": int_response,
    "wopCollectGarbage": wopCollectGarbage_response,
}
wop_response_parsers = op_response

def parse_wop(wop, bs):
    if wop in wop_response_parsers:
        parser = wop_response_parsers[wop]
        everything = Struct(
            "value"/parser,
            "rest"/construct.GreedyBytes
        )
        parsed = everything.parse(bs)
        return parsed.value, parsed.rest
    else:
        return None, bs

stderr_write = Struct(
    "type"/Const(stderr_enum, "STDERR_WRITE"),
    "data"/nixstr
)
stderr_read = Struct(
    "type"/Const(stderr_enum, "STDERR_READ"),
)
stderr_error = Struct(
    "type"/Const(stderr_enum, "STDERR_ERROR"),
    "error"/nixstr,
    "status"/Int64ul
)
stderr_next = Struct(
    "type"/Const(stderr_enum, "STDERR_NEXT"),
    "data"/nixstr
)
logger_field_type_enum = construct.Enum(Int64ul,
    int=0,
    string=1
)
logger_field = construct.Select(
    Struct(
        "type"/Const(logger_field_type_enum, "int"),
        "number"/Int64ul
    ),
    Struct(
        "type"/Const(logger_field_type_enum, "string"),
        "number"/nixstr
))
activity_id = Int64ul
verbosity_level_to_dict = {
    "lvlError": 0,
    "lvlInfo": 1,
    "lvlTalkative": 2,
    "lvlChatty": 3,
    "lvlDebug": 4,
    "lvlVomit": 5,
}
verbosity_level_enum = construct.Enum(Int64ul, **verbosity_level_to_dict)
activity_type_to_dict = {
    "actUnknown": 0,
    "actCopyPath": 100,
    "actDownload": 101,
    "actRealise": 102,
    "actCopyPaths": 103,
    "actBuilds": 104,
    "actBuild": 105,
    "actOptimiseStore": 106,
    "actVerifyPaths": 107,
    "actSubstitute": 108,
    "actQueryPathInfo": 109,
}
activity_type_enum = construct.Enum(Int64ul, **activity_type_to_dict)
stderr_start_activity = Struct(
    "type"/Const(stderr_enum, "STDERR_START_ACTIVITY"),
    "activity"/activity_id,
    "verbosity_level"/verbosity_level_enum,
    "activity_type"/activity_type_enum,
    "string"/nixstr,
    "fields"/construct.PrefixedArray(Int64ul, logger_field),
    "parent"/activity_id
)
stderr_stop_activity = Struct(
    "type"/Const(stderr_enum, "STDERR_STOP_ACTIVITY"),
    "activity"/activity_id
)
result_type_to_dict = {
    "resFileLinked": 100,
    "resBuildLogLine": 101,
    "resUntrustedPath": 102,
    "resCorruptedPath": 103,
    "resSetPhase": 104,
    "resProgress": 105,
    "resSetExpected": 106,
}
result_type_enum = construct.Enum(Int64ul, **result_type_to_dict)
stderr_result = Struct(
    "type"/Const(stderr_enum, "STDERR_RESULT"),
    "activity"/activity_id,
    "result_type"/result_type_enum,
    "fields"/construct.PrefixedArray(Int64ul, logger_field),
)
stderr_last = Struct(
    "type"/Const(stderr_enum, "STDERR_LAST")
)
stderr_operation = construct.Select(
    stderr_write,
    stderr_read,
    stderr_error,
    stderr_next,
    stderr_start_activity,
    stderr_stop_activity,
    stderr_result,
    stderr_last
)
stderr = Struct(
    construct.Probe(),
    "stderr"/construct.GreedyRange(stderr_operation),
    construct.Probe(),
    Const(stderr_enum, "STDERR_LAST")
)
server_header = Struct(
    Const(Int64ul, WORKER_MAGIC_2),
    "server_version"/Int64ul
)
def parse_with(subcon, bys):
    return Struct(
        construct.Embedded(construct.Select(construct.Struct("value"/subcon), Struct())),
        "rest"/construct.GreedyBytes
    ).parse(bys)

class Client:
    def __init__(self):
        self.buf = bytes()
        self.offset = 0
        self.state = "start"

    def _unpack(self, fmt):
        ret = struct.unpack_from(fmt, self.buf, offset=self.offset)
        self.offset += struct.calcsize(fmt)
        return ret

    def _unpack_rest(self):
        ret = self.buf[self.offset:]
        self.offset += len(ret)
        return ret

    def feed_data_from_server(self, data):
        self.buf += data
        if self.state == "start":
            magic, server_version = self._unpack("LL")
            must_equal(magic, WORKER_MAGIC_2)
            self.state = "running"
            return f"WORKER_MAGIC_2 server_version:{server_version:#0x}"
        else:
            rest = self._unpack_rest()
            # TODO use construct.Optional instead? need to also wrap it with something to get the bytes consumed then
            # TODO also need to wrap all my definitions in a version thingy
            # okay, let's transform this to asyncio calls!
            # oh, wait, let's do that with the server first
            parsed = parse_with(stderr_operation, rest)
            stderr_value = parsed.value
            rest = parsed.rest
            if stderr_value.type != "STDERR_LAST":
                self.offset -= len(rest)
                return f"{stderr_value}"
            wop = self.state
            self.state = "running"
            value, rest = parse_wop(wop, rest)
            if value is not None:
                if len(rest) == 0:
                    return f"wop:{wop} response:{value}"
                else:
                    return f"wop:{wop} response:{value} rest:{rest}"
            else:
                return f"{stderr_value} state:{wop} {rest}"
        raise Exception("unknown client state", self.state, "bytes", self.buf[self.offset:])

    def send_wop(self, wop):
        pass

    def call_wop(self, wop):
        self.send_wop(wop)
        assert(self.state == "running")
        self.state = wop

client_hello = Const(Int64ul, WORKER_MAGIC_1)
server_hello_ack = Struct(
    Const(Int64ul, WORKER_MAGIC_2),
    "server_version"/Int64ul
)
client_ack = Struct(
    "client_version"/Int64ul,
    "should_set_affinity"/Int64ul,
    "cpu_affinity"/construct.If(construct.this.should_set_affinity == 1, Int64ul),
    "reserve_space"/Int64ul,
)

def async_fd_blocking_reader(fd):
    async def read():
        return os.read(fd, 4096)
    return read

class Callcc:
    def __init__(self, func):
        self.func = func

    @staticmethod
    def yield_up(value):
        return (yield value)

    def __await__(self):
        return self.yield_up(self.func)

def callcc(func):
    return Callcc(func)

def start(coroutine):
    def trampoline(value):
        try:
            f = coroutine.send(value)
        except StopIteration:
            return
        f(trampoline)
    trampoline(None)

class Channel:
    def __init__(self):
        self.cbs = []

    def send(self, value):
        cbs = self.cbs
        self.cbs = []
        for cb in cbs:
            cb(value)

    def register_callback(self, cb):
        self.cbs.append(cb)

    async def recv(self):
        return (await callcc(self.register_callback))

class DataPoller:
    def __init__(self, read):
        self._read = read
        self.buf = bytes()

    async def wait_for_more(self):
        self.buf += await self._read()

    def available(self):
        return self.buf

    def consume(self, n):
        self.buf = self.buf[n:]

def parse_with_con(con, bytes):
    parsed = construct.Optional(Struct(
        "offset1"/construct.Tell,
        "value"/con,
        "offset2"/construct.Tell
    )).parse(bytes)
    if parsed is not None:
        size = parsed["offset2"] - parsed["offset1"]
        return parsed["value"], size
    else:
        return None, 0

class ConnectedClient:
    def __init__(self, read_con, write_con, server_version, client_configuration):
        self.read_con = read_con
        self.write_con = write_con
        self.server_version = server_version
        self.client_configuration = client_configuration

    async def call(self, op, request):
        write_con = self.write_con
        read_con = self.read_con
        await write_con(op_request[op])
        # TODO need to handle streaming this out in a sane way rather than just printing it
        while True:
            stderr_packet = await read_con(stderr_operation)
            if stderr_packet.type == "STDERR_LAST":
                break
            eprint("[new] <", stderr_packet)
        response = await read_con(op_response[op])
        return response

def nix_client(read, write):
    async def hello():
        reader = DataPoller(read)
        async def read_con(con):
            while True:
                value, consumed = parse_with_con(con, reader.available())
                if value is not None:
                    reader.consume(consumed)
                    return value
                await reader.wait_for_more()
        async def write_con(con):
            return
        await write_con(client_hello)
        server_ack = await read_con(server_hello_ack)
        server_version = server_ack['server_version']
        async def connect_with(client_ack_data):
            await write_con(client_ack)
            return ConnectedClient(read_con, write_con, server_version, client_ack_data)
        return connect_with, server_version
    return hello

class AsyncServer:
    def __init__(self, impl_start, read, write):
        self._impl_start = impl_start
        # I suppose this will throw on EOF?
        self._read = read
        self._write = write

    async def run(self):
        self.reader = DataPoller(self._read)
        async def read_con(con):
            while True:
                value, consumed = parse_with_con(con, self.reader.available())
                if value is not None:
                    self.reader.consume(consumed)
                    return value
                await self.reader.wait_for_more()
        async def write_con(con):
            return
        await read_con(client_hello)
        impl_hello, server_version = await self._impl_start()
        await write_con(server_hello_ack)
        ack = await read_con(client_ack)
        impl = await impl_hello(ack)
        while True:
            op = await read_con(wop_enum)
            request = await read_con(op_request[op])
            # TODO need to pull stderr out of impl.call
            response = await impl.call(op, request)
            await write_con(op_response[op])

class PrintingConnectedClient:
    def __init__(self, client):
        self.client = client

    async def call(self, op, request):
        eprint("[new] >", op, request)
        response = await self.client.call(op, request)
        eprint("[new] <", response)

def printing_nix_client(read, write):
    real_hello = nix_client(read, write)
    async def hello():
        real_connect_with, server_version = await real_hello()
        eprint(f"[new] < server connection response, version:{server_version:#0x}")
        async def connect_with(ack):
            client_version = ack['client_version']
            del ack['client_version']
            eprint(f"[new] > client connection response, version:{client_version:#0x}, ", ack)
            real_client = await real_connect_with(ack)
            return PrintingConnectedClient(real_client)
        return connect_with, server_version
    return hello

async def dummy_write(data):
    eprint("wrote out", data)

def main():
    stdin_channel = Channel()
    stdout_channel = Channel()
    servobj = AsyncServer(printing_nix_client(stdout_channel.recv, dummy_write),
                          stdin_channel.recv, dummy_write)
    start(servobj.run())
    
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    
    server_address = "/nix/var/nix/daemon-socket/socket"
    sock.connect(server_address)
    
    sel = selectors.DefaultSelector()
    
    sel.register(sock, selectors.EVENT_READ)
    sel.register(sys.stdin.buffer, selectors.EVENT_READ)

    while len(sel.get_map()) > 0:
        tuples = sel.select()
        for key, events in tuples:
            if key.fileobj is sock:
                data = sock.recv(4096)
                if len(data) == 0:
                    eprint("got eof on socket")
                    sel.unregister(sock)
                    sys.stdout.close()
                    continue
                stdout_channel.send(data)
                sent = os.write(sys.stdout.buffer.fileno(), data)
                if sent != len(data):
                    raise Exception("partial send from sock to stdout")
            if key.fileobj is sys.stdin.buffer:
                data = os.read(sys.stdin.buffer.fileno(), 4096)
                if len(data) == 0:
                    eprint("got eof on stdin")
                    sel.unregister(sys.stdin.buffer)
                    sock.shutdown(socket.SHUT_WR)
                    continue
                stdin_channel.send(data)
                sent = sock.send(data)
                if sent != len(data):
                    raise Exception("partial send from stdin to sock")
    eprint("DONE")
if __name__ == '__main__':
    main()

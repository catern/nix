#!/usr/bin/env python3

import socket
import sys
import os
import selectors
import struct

import nar
import construct

sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)

server_address = "/nix/var/nix/daemon-socket/socket"
sock.connect(server_address)

sel = selectors.DefaultSelector()

sel.register(sock, selectors.EVENT_READ)
sel.register(sys.stdin.buffer, selectors.EVENT_READ)

def eprint(*args, **kwargs):
    kwargs['file'] = sys.stderr
    print(*args, **kwargs)

class Message:
    def __init__(self, data, string_rep=None):
        self.data = data
        self.string_rep = string_rep

    def __str__(self):
        return self.string_rep

WORKER_MAGIC_1 = 0x6e697863
WORKER_MAGIC_2 = 0x6478696f
stderr_op_to_num = {
    "STDERR_NEXT": 0x6f6c6d67,
    "STDERR_READ": 0x64617461,
    "STDERR_WRITE": 0x64617416,
    "STDERR_LAST": 0x616c7473,
    "STDERR_ERROR": 0x63787470,
    "STDERR_START_ACTIVITY": 0x53545254,
    "STDERR_STOP_ACTIVITY": 0x53544f50,
    "STDERR_RESULT": 0x52534c54,
}
wop_to_num = {
    "wopIsValidPath": 1,
    "wopHasSubstitutes": 3,
    "wopQueryPathHash": 4,
    "wopQueryReferences": 5,
    "wopQueryReferrers": 6,
    "wopAddToStore": 7,
    "wopAddTextToStore": 8,
    "wopBuildPaths": 9,
    "wopEnsurePath": 10,
    "wopAddTempRoot": 11,
    "wopAddIndirectRoot": 12,
    "wopSyncWithGC": 13,
    "wopFindRoots": 14,
    "wopExportPath": 16,
    "wopQueryDeriver": 18,
    "wopSetOptions": 19,
    "wopCollectGarbage": 20,
    "wopQuerySubstitutablePathInfo": 21,
    "wopQueryDerivationOutputs": 22,
    "wopQueryAllValidPaths": 23,
    "wopQueryFailedPaths": 24,
    "wopClearFailedPaths": 25,
    "wopQueryPathInfo": 26,
    "wopImportPaths": 27,
    "wopQueryDerivationOutputNames": 28,
    "wopQueryPathFromHashPart": 29,
    "wopQuerySubstitutablePathInfos": 30,
    "wopQueryValidPaths": 31,
    "wopQuerySubstitutablePaths": 32,
    "wopQueryValidDerivers": 33,
    "wopOptimiseStore": 34,
    "wopVerifyStore": 35,
    "wopBuildDerivation": 36,
    "wopAddSignatures": 37,
    "wopNarFromPath": 38,
    "wopAddToStoreNar": 39,
    "wopQueryMissing": 40,
}
nixstr = construct.Aligned(8, construct.PascalString(construct.Int64ul, encoding="utf8"))
from construct import Struct, Const, Int64ul
wop_enum = construct.Enum(Int64ul, **wop_to_num)
stderr_enum = construct.Enum(Int64ul, **stderr_op_to_num)
wopSetOptions = Struct(
    "type" / Const(wop_enum, "wopSetOptions"),
    "keepFailed" / Int64ul,
    "keepGoing" / Int64ul,
    "tryFallback" / Int64ul,
    "verbosity" / Int64ul,
    "maxBuildJobs" / Int64ul,
    "maxSilentTime" / Int64ul,
    "useBuildHook" / Int64ul,
    "verboseBuild" / Int64ul,
    "logType" / Int64ul,
    "printBuildTrace" / Int64ul,
    "buildCores" / Int64ul,
    "useSubstitutes" / Int64ul,
    "overrides" / construct.PrefixedArray(Int64ul, Struct(
        "option" / nixstr,
        "value" / nixstr
    ))
)
wopIsValidPath = Struct(
    "type" / Const(wop_enum, "wopIsValidPath"),
    "path" / nixstr
)
wopEnsurePath = Struct(
    "type" / Const(wop_enum, "wopEnsurePath"),
    "path" / nixstr
)
wopAddToStore = Struct(
    "type" / Const(wop_enum, "wopAddToStore"),
    "baseName" / nixstr,
    "fixed" / Int64ul,
    "recursive" / Int64ul,
    "hashType" / nixstr,
    "nar" / nar.dump
)
wopBuildPaths = Struct(
    "type" / Const(wop_enum, "wopBuildPaths"),
    "paths" / construct.PrefixedArray(Int64ul, nixstr),
    "mode" / Int64ul
)
wopQueryPathInfo = Struct(
    "type" / Const(wop_enum, "wopQueryPathInfo"),
    "path" / nixstr
)
operation = Struct(
    "value"/construct.Select(
        wopSetOptions,
        wopAddToStore,
        wopIsValidPath,
        wopEnsurePath,
        wopBuildPaths,
        wopQueryPathInfo,
        Struct("just_type"/wop_enum)),
    "rest"/construct.GreedyBytes,
)

num_to_wop = { num:wop for (wop, num) in wop_to_num.items() }

def must_equal(a, b):
    if a != b:
        raise Exception("protocol error:", a, "!=", b)

empty_response = Struct(
)
int_response = Struct(
    "ret" / Int64ul
)
path_response = Struct(
    "path" / nixstr
)
pathinfo_response = Struct(
    # daemon version 17 and above
    # "valid" / Int64ul,
    "deriver"/nixstr,
    "narHash"/nixstr,
    "references" / construct.PrefixedArray(Int64ul, nixstr),
    "registrationTime"/Int64ul,
    "narSize"/Int64ul,
    # daemon version 16 and above
    # "ultimate"/Int64ul,
    # "sigs" / construct.PrefixedArray(Int64ul, nixstr),
    # "ca"/nixstr,
)
wop_response_parsers = {
    "wopSetOptions": empty_response,
    "wopIsValidPath": int_response,
    "wopEnsurePath": int_response,
    "wopBuildPaths": int_response,
    "wopAddToStore": path_response,
    "wopQueryPathInfo": pathinfo_response,
}
def parse_wop(wop, bs):
    if wop in wop_response_parsers:
        parser = wop_response_parsers[wop]
        everything = Struct(
            "value"/parser,
            "rest"/construct.GreedyBytes
        )
        parsed = everything.parse(bs)
        return parsed.value, parsed.rest
    else:
        return None, bs

stderr = Struct(
    "value"/Const(stderr_enum, "STDERR_LAST"),
    "rest"/construct.GreedyBytes
)
server_header = Struct(
    Const(Int64ul, WORKER_MAGIC_2),
    "server_version"/Int64ul
)

class Client:
    def __init__(self):
        self.buf = bytes()
        self.offset = 0
        self.state = "start"

    def _unpack(self, fmt):
        ret = struct.unpack_from(fmt, self.buf, offset=self.offset)
        self.offset += struct.calcsize(fmt)
        return ret

    def _unpack_rest(self):
        ret = self.buf[self.offset:]
        self.offset += len(ret)
        return ret

    def feed_data_from_server(self, data):
        self.buf += data
        if self.state == "start":
            magic, server_version = self._unpack("LL")
            must_equal(magic, WORKER_MAGIC_2)
            self.state = "running"
            return f"WORKER_MAGIC_2 server_version:{server_version:#0x}"
        else:
            parsed = stderr.parse(self._unpack_rest())
            stderr_value = parsed.value
            rest = parsed.rest
            wop = self.state
            self.state = "running"
            value, rest = parse_wop(wop, rest)
            if value is not None:
                if len(rest) == 0:
                    return f"{stderr_value} wop:{wop} response:{value}"
                else:
                    return f"{stderr_value} wop:{wop} response:{value} rest:{rest}"
            else:
                return f"{stderr_value} state:{wop} {rest}"
        raise Exception("unknown client state", self.state, "bytes", self.buf[self.offset:])

    def send_wop(self, wop):
        pass

    def call_wop(self, wop):
        self.send_wop(wop)
        assert(self.state == "running")
        self.state = wop

class WorkerProtocolAPI:
    def wop_called(self, wop):
        raise NotImplementedError

class DissectorAdaptor(WorkerProtocolAPI):
    def __init__(self, client):
        self.client = client

    def wop_called(self, wop):
        self.client.call_wop(wop)

class Server:
    def __init__(self, impl):
        self.buf = bytes()
        self.offset = 0
        self.state = "start"
        self.impl = impl

    def _unpack(self, fmt):
        ret = struct.unpack_from(fmt, self.buf, offset=self.offset)
        self.offset += struct.calcsize(fmt)
        return ret

    def _unpack_bytes(self, n):
        ret = self.buf[self.offset:self.offset+n]
        self.offset += n
        return ret

    def _unpack_string(self):
        size, = self._unpack("L")
        s = self._unpack_bytes(size).decode()
        padding_size = 8 - (size % 8)
        padding = self._unpack_bytes(padding_size)
        return s

    def _unpack_list_of_strings(self):
        count, = self._unpack("L")
        ret = []
        for _ in range(count):
            ret.append(self._unpack_string())
        return ret

    def _unpack_rest(self):
        additional = len(self.buf) - self.offset
        return self._unpack_bytes(len(self.buf) - self.offset)

    def feed_data(self, data):
        self.buf += data
        # remaining = len(self.buf) - self.offset
        # self.buf = self.buf[self.offset:] + data
        # self.offset = remaining
    
    def feed_data_from_client(self, data):
        self.feed_data(data)
        if self.state == "start":
            magic, = self._unpack("L")
            must_equal(magic, WORKER_MAGIC_1)
            self.state = "receive_client_version"
            return "WORKER_MAGIC_1"
        elif self.state == "receive_client_version":
            client_version, = self._unpack("L")
            ret = f"client_version:{client_version:#0x} "
            should_set_affinity, = self._unpack("L")
            if should_set_affinity:
                cpu_affinity, = self._unpack("L")
                ret += f"should_set_affinity:{should_set_affinity} cpu_affinity:{cpu_affinity} "
            else:
                ret += f"should_set_affinity:{should_set_affinity} "
            reserve_space, = self._unpack("L")
            ret += f"reserve_space:{reserve_space}"
            self.state = "running"
            return ret
        elif self.state == "running":
            parsed = operation.parse(self._unpack_rest())
            val = parsed.value
            self.offset -= len(parsed.rest)
            if "type" in val:
                # lazy hack
                self.impl.wop_called(val.type)
                return val
            else:
                wop = val.just_type
                consumed = self._unpack_rest()
                eprint(f"consuming {len(consumed)} additional bytes")
                return f"{wop} consumed:{consumed}"
        raise Exception("unknown server state", self.state, "bytes", self.buf[self.offset:])

client = Client()
server = Server(impl=DissectorAdaptor(client))
while True:
    tuples = sel.select()
    for key, events in tuples:
        if key.fileobj is sock:
            data = sock.recv(4096)
            if len(data) == 0:
                raise Exception("got EOF on socket")
            response = client.feed_data_from_server(data)
            eprint("<", response)
            sent = os.write(sys.stdout.buffer.fileno(), data)
            if sent != len(data):
                raise Exception("partial send from sock to stdout")
        if key.fileobj is sys.stdin.buffer:
            data = os.read(sys.stdin.buffer.fileno(), 4096)
            if len(data) == 0:
                raise Exception("got EOF on stdin")
            eprint(">", server.feed_data_from_client(data))
            while len(server.buf) > server.offset:
                ret = server.feed_data_from_client(bytes())
                if ret is None:
                    break
                eprint(">", ret)
            sent = sock.send(data)
            if sent != len(data):
                raise Exception("partial send from stdin to sock")

#!/usr/bin/env python3

import socket
import sys
import os
import selectors
import struct

import nar
import construct

def eprint(*args, **kwargs):
    kwargs['file'] = sys.stderr
    print(*args, **kwargs)

WORKER_MAGIC_1 = 0x6e697863
WORKER_MAGIC_2 = 0x6478696f
stderr_op_to_num = {
    "STDERR_NEXT": 0x6f6c6d67,
    "STDERR_READ": 0x64617461,
    "STDERR_WRITE": 0x64617416,
    "STDERR_LAST": 0x616c7473,
    "STDERR_ERROR": 0x63787470,
    "STDERR_START_ACTIVITY": 0x53545254,
    "STDERR_STOP_ACTIVITY": 0x53544f50,
    "STDERR_RESULT": 0x52534c54,
}
wop_to_num = {
    "wopIsValidPath": 1,
    "wopHasSubstitutes": 3,
    "wopQueryPathHash": 4,
    "wopQueryReferences": 5,
    "wopQueryReferrers": 6,
    "wopAddToStore": 7,
    "wopAddTextToStore": 8,
    "wopBuildPaths": 9,
    "wopEnsurePath": 10,
    "wopAddTempRoot": 11,
    "wopAddIndirectRoot": 12,
    "wopSyncWithGC": 13,
    "wopFindRoots": 14,
    "wopExportPath": 16,
    "wopQueryDeriver": 18,
    "wopSetOptions": 19,
    "wopCollectGarbage": 20,
    "wopQuerySubstitutablePathInfo": 21,
    "wopQueryDerivationOutputs": 22,
    "wopQueryAllValidPaths": 23,
    "wopQueryFailedPaths": 24,
    "wopClearFailedPaths": 25,
    "wopQueryPathInfo": 26,
    "wopImportPaths": 27,
    "wopQueryDerivationOutputNames": 28,
    "wopQueryPathFromHashPart": 29,
    "wopQuerySubstitutablePathInfos": 30,
    "wopQueryValidPaths": 31,
    "wopQuerySubstitutablePaths": 32,
    "wopQueryValidDerivers": 33,
    "wopOptimiseStore": 34,
    "wopVerifyStore": 35,
    "wopBuildDerivation": 36,
    "wopAddSignatures": 37,
    "wopNarFromPath": 38,
    "wopAddToStoreNar": 39,
    "wopQueryMissing": 40,
}
nixstr = construct.Aligned(8, construct.PascalString(construct.Int64ul, encoding="utf8"))
from construct import Struct, Const, Int64ul
wop_enum = construct.Enum(Int64ul, **wop_to_num)
stderr_enum = construct.Enum(Int64ul, **stderr_op_to_num)
wopSetOptions = Struct(
    "type" / Const(wop_enum, "wopSetOptions"),
    "keepFailed" / Int64ul,
    "keepGoing" / Int64ul,
    "tryFallback" / Int64ul,
    "verbosity" / Int64ul,
    "maxBuildJobs" / Int64ul,
    "maxSilentTime" / Int64ul,
    "useBuildHook" / Int64ul,
    "verboseBuild" / Int64ul,
    "logType" / Int64ul,
    "printBuildTrace" / Int64ul,
    "buildCores" / Int64ul,
    "useSubstitutes" / Int64ul,
    "overrides" / construct.PrefixedArray(Int64ul, Struct(
        "option" / nixstr,
        "value" / nixstr
    ))
)
wopIsValidPath = Struct(
    "type" / Const(wop_enum, "wopIsValidPath"),
    "path" / nixstr
)
wopEnsurePath = Struct(
    "type" / Const(wop_enum, "wopEnsurePath"),
    "path" / nixstr
)
wopAddToStore = Struct(
    "type" / Const(wop_enum, "wopAddToStore"),
    "baseName" / nixstr,
    "fixed" / Int64ul,
    "recursive" / Int64ul,
    "hashType" / nixstr,
    "nar" / nar.dump
)
wopAddTextToStore = Struct(
    "type" / Const(wop_enum, "wopAddTextToStore"),
    "baseName" / nixstr,
    "string" / nixstr,
    "references" / construct.PrefixedArray(Int64ul, nixstr)
)
wopBuildPaths = Struct(
    "type" / Const(wop_enum, "wopBuildPaths"),
    "paths" / construct.PrefixedArray(Int64ul, nixstr),
    "mode" / Int64ul
)
wopQueryPathInfo = Struct(
    "type" / Const(wop_enum, "wopQueryPathInfo"),
    "path" / nixstr
)
wopQueryReferrers = Struct(
    "type" / Const(wop_enum, "wopQueryReferrers"),
    "path" / nixstr
)
wopQueryDerivationOutputs = Struct(
    "type" / Const(wop_enum, "wopQueryDerivationOutputs"),
    "path" / nixstr
)
wopAddTempRoot = Struct(
    "type" / Const(wop_enum, "wopAddTempRoot"),
    "path" / nixstr
)
wopFindRoots = Struct(
    "type" / Const(wop_enum, "wopFindRoots")
)
gc_action_to_num = {
    "gcReturnLive": 0,
    "gcReturnDead": 1,
    "gcDeleteDead": 2,
    "gcDeleteSpecific": 3,
}
gc_action_enum = construct.Enum(Int64ul, **gc_action_to_num)
wopCollectGarbage = Struct(
    "type" / Const(wop_enum, "wopCollectGarbage"),
    "action" / gc_action_enum,
    "pathsToDelete" / construct.PrefixedArray(Int64ul, nixstr),
    "ignoreLiveness" / Int64ul,
    "maxFreed" / Int64ul,
    # obselete fields
    Int64ul,
    Int64ul,
    Int64ul
)
operation = construct.Select(
        wopSetOptions,
        wopAddToStore,
        wopAddTextToStore,
        wopIsValidPath,
        wopEnsurePath,
        wopBuildPaths,
        wopQueryPathInfo,
        wopQueryReferrers,
        wopQueryDerivationOutputs,
        wopAddTempRoot,
        wopFindRoots,
        wopCollectGarbage
)

num_to_wop = { num:wop for (wop, num) in wop_to_num.items() }

def must_equal(a, b):
    if a != b:
        raise Exception("protocol error:", a, "!=", b)

map_entry = Struct(
    "key" / nixstr,
    "value" / nixstr
)
empty_response = Struct(
)
int_response = Struct(
    "ret" / Int64ul
)
path_response = Struct(
    "path" / nixstr
)
paths_response = Struct(
    "paths" / construct.PrefixedArray(Int64ul, nixstr)
)
map_response = Struct(
    "entries" / construct.PrefixedArray(Int64ul, map_entry)
)
pathinfo_response = Struct(
    # daemon version 17 and above
    # "valid" / Int64ul,
    "deriver"/nixstr,
    "narHash"/nixstr,
    "references" / construct.PrefixedArray(Int64ul, nixstr),
    "registrationTime"/Int64ul,
    "narSize"/Int64ul,
    # daemon version 16 and above
    # "ultimate"/Int64ul,
    # "sigs" / construct.PrefixedArray(Int64ul, nixstr),
    # "ca"/nixstr,
)
wopCollectGarbage_response = Struct(
    "collectedPaths" / construct.PrefixedArray(Int64ul, nixstr),
    "bytesFreed"/Int64ul,
    # obsolete
    Int64ul,
)
wop_response_parsers = {
    "wopSetOptions": empty_response,
    "wopIsValidPath": int_response,
    "wopEnsurePath": int_response,
    "wopBuildPaths": int_response,
    "wopAddToStore": path_response,
    "wopAddTextToStore": path_response,
    "wopQueryPathInfo": pathinfo_response,
    "wopQueryReferrers": paths_response,
    "wopQueryDerivationOutputs": paths_response,
    "wopAddTempRoot": int_response,
    "wopFindRoots": map_response,
    "wopCollectGarbage": wopCollectGarbage_response,
}
def parse_wop(wop, bs):
    if wop in wop_response_parsers:
        parser = wop_response_parsers[wop]
        everything = Struct(
            "value"/parser,
            "rest"/construct.GreedyBytes
        )
        parsed = everything.parse(bs)
        return parsed.value, parsed.rest
    else:
        return None, bs

stderr_write = Struct(
    "type"/Const(stderr_enum, "STDERR_WRITE"),
    "data"/nixstr
)
stderr_read = Struct(
    "type"/Const(stderr_enum, "STDERR_READ"),
)
stderr_error = Struct(
    "type"/Const(stderr_enum, "STDERR_ERROR"),
    "error"/nixstr,
    "status"/Int64ul
)
stderr_next = Struct(
    "type"/Const(stderr_enum, "STDERR_NEXT"),
    "data"/nixstr
)
logger_field_type_enum = construct.Enum(Int64ul,
    int=0,
    string=1
)
logger_field = construct.Select(
    Struct(
        "type"/Const(logger_field_type_enum, "int"),
        "number"/Int64ul
    ),
    Struct(
        "type"/Const(logger_field_type_enum, "string"),
        "number"/nixstr
))
activity_id = Int64ul
verbosity_level_to_dict = {
    "lvlError": 0,
    "lvlInfo": 1,
    "lvlTalkative": 2,
    "lvlChatty": 3,
    "lvlDebug": 4,
    "lvlVomit": 5,
}
verbosity_level_enum = construct.Enum(Int64ul, **verbosity_level_to_dict)
activity_type_to_dict = {
    "actUnknown": 0,
    "actCopyPath": 100,
    "actDownload": 101,
    "actRealise": 102,
    "actCopyPaths": 103,
    "actBuilds": 104,
    "actBuild": 105,
    "actOptimiseStore": 106,
    "actVerifyPaths": 107,
    "actSubstitute": 108,
    "actQueryPathInfo": 109,
}
activity_type_enum = construct.Enum(Int64ul, **activity_type_to_dict)
stderr_start_activity = Struct(
    "type"/Const(stderr_enum, "STDERR_START_ACTIVITY"),
    "activity"/activity_id,
    "verbosity_level"/verbosity_level_enum,
    "activity_type"/activity_type_enum,
    "string"/nixstr,
    "fields"/construct.PrefixedArray(Int64ul, logger_field),
    "parent"/activity_id
)
stderr_stop_activity = Struct(
    "type"/Const(stderr_enum, "STDERR_STOP_ACTIVITY"),
    "activity"/activity_id
)
result_type_to_dict = {
    "resFileLinked": 100,
    "resBuildLogLine": 101,
    "resUntrustedPath": 102,
    "resCorruptedPath": 103,
    "resSetPhase": 104,
    "resProgress": 105,
    "resSetExpected": 106,
}
result_type_enum = construct.Enum(Int64ul, **result_type_to_dict)
stderr_result = Struct(
    "type"/Const(stderr_enum, "STDERR_RESULT"),
    "activity"/activity_id,
    "result_type"/result_type_enum,
    "fields"/construct.PrefixedArray(Int64ul, logger_field),
)
stderr_last = Struct(
    "type"/Const(stderr_enum, "STDERR_LAST")
)
stderr_operation = construct.Select(
    stderr_write,
    stderr_read,
    stderr_error,
    stderr_next,
    stderr_start_activity,
    stderr_stop_activity,
    stderr_result,
    stderr_last
)
stderr = Struct(
    construct.Probe(),
    "stderr"/construct.GreedyRange(stderr_operation),
    construct.Probe(),
    Const(stderr_enum, "STDERR_LAST")
)
server_header = Struct(
    Const(Int64ul, WORKER_MAGIC_2),
    "server_version"/Int64ul
)
def parse_with(subcon, bys):
    return Struct(
        construct.Embedded(construct.Select(construct.Struct("value"/subcon), Struct())),
        "rest"/construct.GreedyBytes
    ).parse(bys)

class Client:
    def __init__(self):
        self.buf = bytes()
        self.offset = 0
        self.state = "start"

    def _unpack(self, fmt):
        ret = struct.unpack_from(fmt, self.buf, offset=self.offset)
        self.offset += struct.calcsize(fmt)
        return ret

    def _unpack_rest(self):
        ret = self.buf[self.offset:]
        self.offset += len(ret)
        return ret

    def feed_data_from_server(self, data):
        self.buf += data
        if self.state == "start":
            magic, server_version = self._unpack("LL")
            must_equal(magic, WORKER_MAGIC_2)
            self.state = "running"
            return f"WORKER_MAGIC_2 server_version:{server_version:#0x}"
        else:
            rest = self._unpack_rest()
            parsed = parse_with(stderr_operation, rest)
            stderr_value = parsed.value
            rest = parsed.rest
            if stderr_value.type != "STDERR_LAST":
                self.offset -= len(rest)
                return f"{stderr_value}"
            wop = self.state
            self.state = "running"
            value, rest = parse_wop(wop, rest)
            if value is not None:
                if len(rest) == 0:
                    return f"wop:{wop} response:{value}"
                else:
                    return f"wop:{wop} response:{value} rest:{rest}"
            else:
                return f"{stderr_value} state:{wop} {rest}"
        raise Exception("unknown client state", self.state, "bytes", self.buf[self.offset:])

    def send_wop(self, wop):
        pass

    def call_wop(self, wop):
        self.send_wop(wop)
        assert(self.state == "running")
        self.state = wop

class WorkerProtocolAPI:
    def wop_called(self, wop):
        raise NotImplementedError

class DissectorAdaptor(WorkerProtocolAPI):
    def __init__(self, client):
        self.client = client

    def wop_called(self, wop):
        self.client.call_wop(wop)

class Server:
    def __init__(self, impl):
        self.buf = bytes()
        self.offset = 0
        self.state = "start"
        self.impl = impl

    def _unpack(self, fmt):
        ret = struct.unpack_from(fmt, self.buf, offset=self.offset)
        self.offset += struct.calcsize(fmt)
        return ret

    def _unpack_bytes(self, n):
        ret = self.buf[self.offset:self.offset+n]
        self.offset += n
        return ret

    def _unpack_string(self):
        size, = self._unpack("L")
        s = self._unpack_bytes(size).decode()
        padding_size = 8 - (size % 8)
        padding = self._unpack_bytes(padding_size)
        return s

    def _unpack_list_of_strings(self):
        count, = self._unpack("L")
        ret = []
        for _ in range(count):
            ret.append(self._unpack_string())
        return ret

    def _unpack_rest(self):
        additional = len(self.buf) - self.offset
        return self._unpack_bytes(len(self.buf) - self.offset)

    def _rest(self):
        return self.buf[self.offset:]

    def feed_data(self, data):
        self.buf += data
        # remaining = len(self.buf) - self.offset
        # self.buf = self.buf[self.offset:] + data
        # self.offset = remaining
    
    def feed_data_from_client(self, data):
        self.feed_data(data)
        if self.state == "start":
            magic, = self._unpack("L")
            must_equal(magic, WORKER_MAGIC_1)
            self.state = "receive_client_version"
            return "WORKER_MAGIC_1"
        elif self.state == "receive_client_version":
            client_version, = self._unpack("L")
            ret = f"client_version:{client_version:#0x} "
            should_set_affinity, = self._unpack("L")
            if should_set_affinity:
                cpu_affinity, = self._unpack("L")
                ret += f"should_set_affinity:{should_set_affinity} cpu_affinity:{cpu_affinity} "
            else:
                ret += f"should_set_affinity:{should_set_affinity} "
            reserve_space, = self._unpack("L")
            ret += f"reserve_space:{reserve_space}"
            self.state = "running"
            return ret
        elif self.state == "running":
            rest = self._unpack_rest()
            parsed = parse_with(operation, rest)
            self.offset -= len(parsed.rest)
            if "value" not in parsed:
                eprint("working on", wop_enum.parse(self._rest()[:8]))
                return None
            val = parsed.value
            self.impl.wop_called(val.type)
            return val
        raise Exception("unknown server state", self.state, "bytes", self.buf[self.offset:])

def main():
    client = Client()
    server = Server(impl=DissectorAdaptor(client))
    
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    
    server_address = "/nix/var/nix/daemon-socket/socket"
    sock.connect(server_address)
    
    sel = selectors.DefaultSelector()
    
    sel.register(sock, selectors.EVENT_READ)
    sel.register(sys.stdin.buffer, selectors.EVENT_READ)

    while len(sel.get_map()) > 0:
        tuples = sel.select()
        for key, events in tuples:
            if key.fileobj is sock:
                data = sock.recv(4096)
                if len(data) == 0:
                    eprint("got eof on socket")
                    sel.unregister(sock)
                    sys.stdout.close()
                    continue
                ret = client.feed_data_from_server(data)
                if ret is not None:
                    eprint("<", ret)
                while len(client.buf) > client.offset:
                    ret = client.feed_data_from_server(bytes())
                    if ret is None:
                        break
                    eprint("<", ret)
                sent = os.write(sys.stdout.buffer.fileno(), data)
                if sent != len(data):
                    raise Exception("partial send from sock to stdout")
            if key.fileobj is sys.stdin.buffer:
                data = os.read(sys.stdin.buffer.fileno(), 4096)
                if len(data) == 0:
                    eprint("got eof on stdin")
                    sel.unregister(sys.stdin.buffer)
                    sock.shutdown(socket.SHUT_WR)
                    continue
                ret = server.feed_data_from_client(data)
                if ret is not None:
                    eprint(">", ret)
                while len(server.buf) > server.offset:
                    ret = server.feed_data_from_client(bytes())
                    if ret is None:
                        break
                    eprint(">", ret)
                sent = sock.send(data)
                if sent != len(data):
                    raise Exception("partial send from stdin to sock")
    eprint("DONE")
if __name__ == '__main__':
    main()
